[
    {
        "type": "Superalgos Project",
        "definition": "The Superalgos Project hierarchy governs the assets that relate to Superalgos. In its current state, it serves the purpose of spawning hierarchies.",
        "content": [
            {
                "style": "Text",
                "text": "Superalgos is a multi-project platform meaning that other crypto-projects may be integrated. It is in this context that project-specific hierarchies exist."
            },
            {
                "style": "Text",
                "text": "A crypto-project integration means that Superalgos users will able to connect to blockchain nodes from within Superalgos, exposing the blockchain data to the rest of the Superalgos infrastructure. Users will be able to mine the node's data, build indicators, use them from within trading systems, and visualize blockchain information on the charts&mdash;among other things."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the superalgos project node, select <i>Add Missing Projects</i> on the workspace node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "</code\">"
            }
        ],
        "starting": []
    },
    {
        "type": "Project Definition"
    },
    {
        "type": "Spaces",
        "definition": "Spaces refers to the different types of spaces for which definitions exist in the form of hierarchies. At this stage, the node may spawn the Design Space and the Charting Space hierarchies.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the spaces node, select <i>Add Spaces</i> on the parent node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "</code\">"
            }
        ],
        "starting": []
    },
    {
        "type": "Mines",
        "definition": "Mines refers to the different types of mines for which definitions exist in the form of hierarchies. At this stage, the node may spawn Data Mine, Trading Mine, and Learning Mine hierarchies.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the mines node, select <i>Add Mines</i> on the parent node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "</code\">"
            }
        ],
        "starting": []
    },
    {
        "type": "Other Hierarchies",
        "definition": "Other hierarchies refers to hierarchies other than those defining spaces and mines. At this stage, the node may spawn Trading System, Network, Super Scripts, Trading Engine, and Tutorial hierarchies.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the other hierarchies node, select <i>Add Other Hierarchies</i> on the parent node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "</code\">"
            }
        ],
        "starting": []
    },
    {
        "type": "Workspace"
    },
    {
        "type": "Plotter Module",
        "definition": "A plotter module is a device within a plotter that contains the definitions to create the visualization for a product definition.",
        "content": [
            {
                "style": "Text",
                "text": "A single plotter may have several modules. Different modules may be used to plot each product of the bot, or as best suits the expected use-pattern."
            },
            {
                "style": "Text",
                "text": "<img src=\"Projects/Superalgos/Docs-Gifs/plotter-module-01.gif\"></img>"
            },
            {
                "style": "Important",
                "text": "For a bot to use a plotter, the corresponding product definition must establish a reference with the plotter module built to interpret the dataset."
            },
            {
                "style": "Text",
                "text": "<img src=\"Projects/Superalgos/Docs-Gifs/plotter-module-02-product-link.gif\"></img>"
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a plotter module, select <i>Add Plotter Module</i> on the plotter node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure Plotter Module</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "    \"codeName\": \"Module Name\","
            },
            {
                "style": "Text",
                "text": "    \"isLegacy\": true,"
            },
            {
                "style": "Text",
                "text": "        \"icon\": \"histogram\""
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">codeName</code> is the name used in the code to refer to the module.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">isLegacy</code> is <code class=\"language-none\">true<code class=\"language-none\"> for plotters modules developed entirely in JavaScript, and is </code>false</code> or doesn't show in the configuration for plotters built with the tools featured in the data mine hierarchy.</li>"
            },
            {
                "style": "Text",
                "text": "</ul>"
            },
            {
                "style": "Text",
                "text": "<table class=\"docs-table\"><tr><td> Value </td><td> Image</td></tr>"
            },
            {
                "style": "Text",
                "text": "<tr><td> :---: </td><td> :---: </td></tr>"
            },
            {
                "style": "Text",
                "text": "<tr><td> <code class=\"language-none\">default</code> </td><td> <img src=\"Projects/Superalgos/Icons/default-banner.png\"></img> </td></tr>"
            },
            {
                "style": "Text",
                "text": "<tr><td> <code class=\"language-none\">histogram</code> </td><td> <img src=\"Projects/Superalgos/Icons/histogram-banner.png\"></img> </td></tr>"
            },
            {
                "style": "Text",
                "text": "<tr><td> <code class=\"language-none\">band</code> </td><td> <img src=\"Projects/Superalgos/Icons/bands-banner.png\"></img> </td></tr>"
            },
            {
                "style": "Text",
                "text": "<tr><td> <code class=\"language-none\">moving-average</code> </td><td> <img src=\"Projects/Superalgos/Icons/moving-average-banner.png\"></img> </td></tr>"
            },
            {
                "style": "Text",
                "text": "<tr><td> <code class=\"language-none\">oscillator</code> </td><td> <img src=\"Projects/Superalgos/Icons/oscillator-banner.png\"></img> </td></tr>"
            },
            {
                "style": "Text",
                "text": "<tr><td> <code class=\"language-none\">trend</code> </td><td> <img src=\"Projects/Superalgos/Icons/trends-banner.png\"></img> </td></tr>"
            },
            {
                "style": "Text",
                "text": "</table>Custom images may be added too. To do that:"
            },
            {
                "style": "Text",
                "text": "1. name the image in the following format: <code class=\"language-none\">image-name.png</code>;"
            },
            {
                "style": "Text",
                "text": "1. place images in the <code class=\"language-none\">WebServer\\Images\\Icons</code> folder;"
            },
            {
                "style": "Text",
                "text": "1. in the configuration of the module, use the name as is (e.g.: <code class=\"language-none\">\"icon\": \"image-name\"</code>)"
            }
        ],
        "starting": []
    },
    {
        "type": "Nodes Values"
    },
    {
        "type": "Nodes Highlights"
    },
    {
        "type": "Nodes Errors"
    },
    {
        "type": "Nodes Warnings"
    },
    {
        "type": "Nodes Infos"
    },
    {
        "type": "Nodes Status"
    },
    {
        "type": "Nodes Progress"
    },
    {
        "type": "Nodes Running"
    },
    {
        "type": "Nodes Announcements"
    },
    {
        "type": "Record Values"
    },
    {
        "type": "Shapes",
        "definition": "The shapes node contains definitions of polygons and styles to be rendered on a per-period basis over the charts.",
        "content": [
            {
                "style": "Text",
                "text": "A plotter recursively renders graphics for each period or candle. This means that a definition of what shapes need to be drawn for a single period is required. The plotter does the same thing for every period or candle that is visible on the screen at any point in time, for any time frame, as long as the corresponding data is available."
            },
            {
                "style": "Text",
                "text": "<img src=\"Projects/Superalgos/Docs-Gifs/shapes-01-show-off.gif\"></img>"
            },
            {
                "style": "Text",
                "text": "In general terms, the process of defining what is going to be rendered on the screen consist of the following four steps:"
            },
            {
                "style": "Text",
                "text": " 1. Identifying points defined by <code class=\"language-none\">[x,y]</code> coordinates"
            },
            {
                "style": "Text",
                "text": " 2. Defining polygons"
            },
            {
                "style": "Text",
                "text": " 3. Defining default styles"
            },
            {
                "style": "Text",
                "text": " 4. Defining conditional styles"
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a shapes node, select <i>Add Shapes</i> on the plotter module menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Plotter Panel",
        "definition": "A plotter panel usually shows numerical representations of data over the charts on a small window or panel. The plotter panel node features definitions to make that possible.",
        "content": [
            {
                "style": "Text",
                "text": "Beyond the graphic representation of data over the charts, plotters may also feature a <i>data panel</i>, that is, a numerical representation of the data showing the exact figures corresponding to the column or period that is in focus (the point of the charts where the mouse pointer is at any point)."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a plotter panel, select <i>Add Plotter Panel</i> on the plotter module node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Panel Data",
        "definition": "A panel data node represents a data field to be plotted on the plotter panel.",
        "content": [
            {
                "style": "Text",
                "text": "The system renders a panel featuring a centered, single-column vertical arrangement of data, with a label and a data field right below it. The label of each data field on the panel is given&mdash;by default&mdash;by the label set for each panel data node."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a panel data node, select <i>Add Panel Data</i> on the plotter panel menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure Panel Data</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "    \"valueDecimals\": 2"
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">valueDecimals</code> sets the number of decimals to be shown on the corresponding data field.</li>"
            },
            {
                "style": "Text",
                "text": "</ul>"
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "    \"labelText\": \"The Label\","
            },
            {
                "style": "Text",
                "text": "    \"labelPosition\": 15,"
            },
            {
                "style": "Text",
                "text": "    \"valuePosition\": 20,"
            },
            {
                "style": "Text",
                "text": "    \"valueDecimals\": 2"
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">labelPosition</code> and <code class=\"language-none\">valuePosition</code> represent the vertical distance of the corresponding fields to the top margin of the panel.</li></ul>"
            }
        ],
        "starting": []
    },
    {
        "type": "Data Formula",
        "definition": "A data formula is a device used to assign a value to the panel data, usually in the form of the name of the corresponding record property.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add a data formula, select <i>Add Data Formula</i> on the plotter panel menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Javascript Code",
        "definition": "The JavaScript code node may hold any snippet of valid JavaScript.",
        "content": [
            {
                "style": "Text",
                "text": "The system allows developers great flexibility as all valid JavaScript code is allowed."
            },
            {
                "style": "Important",
                "text": "Until a robust JavaScript editor is implemented on the UI, it is recommended to write code on an external editor and paste it in the UI code bubble to ensure consistency."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a JavaScript code node, select <i>Add Code</i> on the corresponding parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Chart Points",
        "definition": "A chart points groups definitions of coordinate points used to define polygons.",
        "content": [
            {
                "style": "Text",
                "text": "The definition of a point consists of the name of the point and the corresponding values for the <code class=\"language-none\">x</code> and <code class=\"language-none\">y</code> coordinates. To create such definitions, point and point formulas are used."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a chart points node, select <i>Add Chart Points</i> on the shapes menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Point",
        "definition": "A point is a definition of an [x,y] coordinate. The value [x] usually represents a datetime. The value [y] may refer to a price or some other concept.",
        "content": [
            {
                "style": "Text",
                "text": "These coordinate points are used to define polygons. Values for <code class=\"language-none\">[x,y]</code>coordinates are entered with a point formula."
            },
            {
                "style": "Text",
                "text": "{% include tip.html content=\"Each point should be given a significant name so that it is easier to identify them at the time of establishing references with polygon vertices.\" %}"
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a point, select <i>Add Point</i> on the chart points node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Point Formula",
        "definition": "A point formula is a node used to input the [x,y] coordinates of a point.",
        "content": [
            {
                "style": "Text",
                "text": "To represent some form of variation of the price or a price derivative over time, a typical point formula consists of the following two coordinates: <code class=\"language-none\">x = datetime</code> and <code class=\"language-none\">y = rate</code>."
            },
            {
                "style": "Text",
                "text": "For example:"
            },
            {
                "style": "Text",
                "text": "<b>Point <i>SMA 20 Begin</i></b>"
            },
            {
                "style": "Text",
                "text": "<code class=\"language-js\">"
            },
            {
                "style": "Text",
                "text": "x = record.begin"
            },
            {
                "style": "Text",
                "text": "y = record.previous.sma20"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "The example above shows the definition of the first of two points necessary to draw the segment of the 20-periods SMA curve for any particular period or candle. In this case, <code class=\"language-none\">x = record.begin</code> is the starting datetime of the period and <code class=\"language-none\">y = record.previous.sma20</code> is the rate of the 20-periods SMA of the previous period."
            },
            {
                "style": "Note",
                "text": "The above variables are constructed with information originating at the product definition that references the corresponding plotter module."
            },
            {
                "style": "Text",
                "text": "To complete the line segment corresponding to a single period, the closing datetime of the period and the closing rate for the 20-periods SMA are required:"
            },
            {
                "style": "Text",
                "text": "<b>Point <i>SMA 20 End</i></b>"
            },
            {
                "style": "Text",
                "text": "<code class=\"language-js\">"
            },
            {
                "style": "Text",
                "text": "x = record.end"
            },
            {
                "style": "Text",
                "text": "y = record.sma20"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "The above system works very well for plotting all sorts of information over the candles, on the charts."
            },
            {
                "style": "Text",
                "text": "An oscillator like RSI too needs the definition of the starting and ending datetime of the period as the value for the <i>x-axis</i>. However, the value for <i>axis y</i> fits a different scale."
            },
            {
                "style": "Text",
                "text": "Anyway, the points definition is just as straight forward, for example:"
            },
            {
                "style": "Text",
                "text": "<b>Point <i>RSI Begin</i></b>"
            },
            {
                "style": "Text",
                "text": "<code class=\"language-js\">"
            },
            {
                "style": "Text",
                "text": "x = record.begin"
            },
            {
                "style": "Text",
                "text": "y = record.previous.value"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<b>Point <i>RSI End</i></b>"
            },
            {
                "style": "Text",
                "text": "<code class=\"language-js\">"
            },
            {
                "style": "Text",
                "text": "x = record.end"
            },
            {
                "style": "Text",
                "text": "y = record.value"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "Points do not necessarily need to refer to values on the dataset produced by the corresponding data product. For example, absolute values for the <i>y-axis</i> may be used to describe fixed graphical elements, for instance, a horizontal line, or a box."
            },
            {
                "style": "Text",
                "text": "<b>Point <i>Begin 20</i></b>"
            },
            {
                "style": "Text",
                "text": "<code class=\"language-js\">"
            },
            {
                "style": "Text",
                "text": "x = record.begin"
            },
            {
                "style": "Text",
                "text": "y = 20"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<b>Point <i>End 20</i></b>"
            },
            {
                "style": "Text",
                "text": "<code class=\"language-js\">"
            },
            {
                "style": "Text",
                "text": "x = record.end"
            },
            {
                "style": "Text",
                "text": "y = 20"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<b>Point <i>Begin 30</i></b>"
            },
            {
                "style": "Text",
                "text": "<code class=\"language-js\">"
            },
            {
                "style": "Text",
                "text": "x = record.begin"
            },
            {
                "style": "Text",
                "text": "y = 30"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<b>Point <i>End 30</i></b>"
            },
            {
                "style": "Text",
                "text": "<code class=\"language-js\">"
            },
            {
                "style": "Text",
                "text": "x = record.end"
            },
            {
                "style": "Text",
                "text": "y = 30"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "The above four points are used to paint the background of the 20 to 30 value range of the RSI chart. The first two points are also used to draw the dotted line signaling the 20-value mark, and the last two are used for the dotted line indicating the 30-value mark."
            },
            {
                "style": "Note",
                "text": "The reason from separating the definition of points from the definition of polygons is that any point may be used by one or more polygons."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a point formula, select <i>Add Point Formula</i> on the point node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Image",
        "definition": "The image node allows overlaying an image over the charts, controlling its position, size, and when it shall be rendered.",
        "content": [
            {
                "style": "Text",
                "text": "The foremost requirement for images is that they are in the <code class=\"language-none\">png</code> format, 24 bits, with transparency, a low case extension, and are square."
            },
            {
                "style": "Text",
                "text": "If you envision contributing your indicator so that the community may use it, then please follow the guidelines in the contribute icons page, in particular, the Technical Requirements."
            },
            {
                "style": "Text",
                "text": "Images must the stored in the following path: <code class=\"language-none\">\\BackendServers\\WebServer\\Images\\Icons\\style-01</code>"
            },
            {
                "style": "Note",
                "text": "See the configuration for further details."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the image node, select <i>Add Image</i> on the parent node menu. "
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "   \"codeName\": \"imagename\","
            },
            {
                "style": "Text",
                "text": "   \"size\": 15"
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">codeName</code> is the name of the image, without the <code class=\"language-none\">.png</code> extension.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">size</code> is the size at which the image shall be rendered, in pixels.</li></ul>"
            }
        ],
        "starting": []
    },
    {
        "type": "Image Condition",
        "definition": "An image condition is a rule that allows establishing when an image shall be rendered and when not.",
        "content": [
            {
                "style": "Text",
                "text": "The node is optional. When the node is not present in the definition of the image or when the condition validates <code class=\"language-none\">true</code>, the image is rendered on screen. When the condition validates <code class=\"language-none\">false</code> the image is not rendered. As such, the node allows dynamically switching the rendering of the corresponding image on and off ."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the image condition node, select <i>Add Image Condition</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Image Position",
        "definition": "The image position node is a reference to a point defined in the chart points, and serves to determine the position in which the image shall be placed.",
        "content": [
            {
                "style": "Text",
                "text": "The image position node works similarly to the polygon vertex in the sense that it must establish a reference with a point in the charts point to acquire a defined coordinate that determines where the image shall be placed."
            },
            {
                "style": "Note",
                "text": "See the configuration for further details."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the image position node, select <i>Add Image Position</i> on the parent node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "   \"offsetX\": 0,"
            },
            {
                "style": "Text",
                "text": "   \"offsetY\": 10"
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">offsetX</code> is an offset in the X axis, in pixels, applied to displace the image in relation to the coordinate point defined by the reference of the node. Negative values displace the image to the left and positive values to the right.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">offsetY</code> is an offset in the Y axis. Negative values displace the image downwards and positive values displace the image upwards.</li></ul>"
            }
        ],
        "starting": []
    },
    {
        "type": "Text",
        "definition": "The text node allows overlaying text on the charts, controlling its position, size, appearance, and when it shall be rendered.",
        "content": [
            {
                "style": "Text",
                "text": "The node's offspring control the different aspects of how, where, and when text shall be rendered over the charts."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the text node, select <i>Add Text</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Text Style",
        "definition": "The text style is a definition of color, opacity, and font size that determines the appearance of the text to be rendered over the charts.",
        "content": [
            {
                "style": "Note",
                "text": "See the configuration for further details."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the text style node, select <i>Add Text Style</i> on the parent node menu. "
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "        \"paletteColor\": \"UI_COLOR.GREY\","
            },
            {
                "style": "Text",
                "text": "        \"opacity\": 0.5,"
            },
            {
                "style": "Text",
                "text": "        \"fontSize\": 10"
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<i> <code class=\"language-none\">paletteColor</code> is one of the predefined colors available, as described in the configuration of the </i>Style* node."
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">opacity</code> is probably self-explanatory, and may range from 0 for a fully transparent object to 1 for a solid object.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">fontSize</code> is self explanatory too; values above zero produce the expected results.</li>"
            },
            {
                "style": "Text",
                "text": "</ul>"
            }
        ],
        "starting": []
    },
    {
        "type": "Text Condition",
        "definition": "A text condition is a rule that allows establishing when text shall be rendered and when not.",
        "content": [
            {
                "style": "Text",
                "text": "The node is optional. When the node is not present in the definition of the text node or when the condition validates <code class=\"language-none\">true</code>, the text is rendered on screen. When the condition validates <code class=\"language-none\">false</code>, text is not rendered. As such, the node allows dynamically switching the rendering of the corresponding text on and off ."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the text condition node, select <i>Add Text Condition</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Text Position",
        "definition": "The text position node is a reference to a point defined in the chart points, and serves to determine the position in which text shall be rendered.",
        "content": [
            {
                "style": "Text",
                "text": "The text position node works similarly to the image position node in the sense that it must establish a reference with a point in the charts point to acquire a defined coordinate that determines where the text shall be placed."
            },
            {
                "style": "Note",
                "text": "See the configuration for further details."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the text position node, select <i>Add Text Position</i> on the parent node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "   \"offsetX\": 0,"
            },
            {
                "style": "Text",
                "text": "   \"offsetY\": 10"
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">offsetX</code> is an offset in the X axis, in pixels, applied to displace the text in relation to the coordinate point defined by the reference of the node. Negative values displace the text to the left and positive values to the right.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">offsetY</code> is an offset in the Y axis. Negative values displace the text downwards and positive values displace the image upwards.</li></ul>"
            }
        ],
        "starting": []
    },
    {
        "type": "Text Formula",
        "definition": "The text formula determines the content that shall be rendered over the charts.",
        "content": [
            {
                "style": "Text",
                "text": "The text formula may use any of the variables available to the plotter, and may produce either a numeric or a text string result."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the text formula node, select <i>Add Text Formula</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Polygon",
        "definition": "A polygon features definitions that makeup shapes and their styles.",
        "content": [
            {
                "style": "Text",
                "text": "Polygons are defined by two or more vertices, which map points in a charts point. The graphic representation of polygons originates in styles applied to either or both polygon bodies and polygon borders."
            },
            {
                "style": "Note",
                "text": "The order in which polygons are ordered around the parent shapes node determines the order in which they are drawn on the screen. In cases on which polygons intersect, those drawn last are drawn on top of those drawn first."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a polygon, select <i>Add Polygon</i> on the shapes node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Polygon Condition",
        "definition": "A polygon condition is a rule that allows establishing when a polygon shall be rendered and when not.",
        "content": [
            {
                "style": "Text",
                "text": "The node is optional. When the node is not present in the definition of the polygon or when the condition validates <code class=\"language-none\">true</code>, the polygon is rendered on screen. When the condition validates <code class=\"language-none\">false</code> the polygon is not rendered. As such, the node allows dynamically switching the rendering of the corresponding polygon on and off."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a polygon condition, select <i>Add Polygon Condition</i> on a polygon node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Edit Condition</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "Polygon conditions work pretty much like conditions used on trading systems. The main difference is that the variables available are solely those provided by the bot product definition that reference the corresponding plotter module."
            }
        ],
        "starting": []
    },
    {
        "type": "Polygon Body",
        "definition": "A polygon body is the fill of a shape made out of at least three vertices.",
        "content": [
            {
                "style": "Text",
                "text": "A polygon body needs at least three vertices to be defined. A body serves to create a <i>fill</i> for the outlines of any sort of polygon, either closed or open, by giving it a style."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a polygon body, select <i>Add Polygon Body</i> on the polygon node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Polygon Border",
        "definition": "A polygon border is a shape defined by at least two vertices used to draw lines or to apply a style to the stroke of a closed shape.",
        "content": [
            {
                "style": "Text",
                "text": "A polygon border needs at least two vertices to be defined. A border serves to create a <i>stroke</i> for the outlines of any sort of polygon, either closed or open, by giving it a style."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a polygon border, select <i>Add Polygon Border</i> on the polygon node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Style Condition",
        "definition": "A style condition is a rule that allows applying an alternative style in cases where the rule validates true.",
        "content": [
            {
                "style": "Text",
                "text": "Style conditions offer a way to introduce additional intelligence on the visual representation of data by using styles that respond to certain conditions."
            },
            {
                "style": "Text",
                "text": "For example, the <i>Percentage Bandwidth</i> plotter module assigns a different color to the Moving Average line when it's going up or down."
            },
            {
                "style": "Text",
                "text": "To do that, a style condition features it's own style so that, when the condition validates true, the new style is applied."
            },
            {
                "style": "Text",
                "text": "Style conditions me be created in a sequence so that the style may continue changing upon the validation of a series of style conditions. The system evaluates all style conditions in a sequential order determined by their position in the rotational symmetry around the parent node. Each condition that is met may modify or add up to the resulting style that is rendered on screen. That is, the final style is the result of the sequential application of the styles defined for each condition that is met, on top of the default style."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a style condition, select <i>Add Style Condition</i> on a polygon border or polygon body node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Edit Condition</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "Style conditions work pretty much like conditions used on trading systems. The main difference is that the variables available are solely those provided by the bot product definition that reference the corresponding plotter module."
            },
            {
                "style": "Text",
                "text": "To continue the example of the Percentage Bandwidth plotter, the following is the condition that determines the newly added styles:"
            },
            {
                "style": "Text",
                "text": "<code class=\"language-js\">"
            },
            {
                "style": "Text",
                "text": "record.previous.movingAverage > record.movingAverage"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "As hinted earlier, when the condition is met, the default style is modified by a second style that may be created on the menu of the style condition node."
            },
            {
                "style": "Text",
                "text": "The definition of secondary styles is slightly different from that of the default style, as&mdash;in such cases&mdash;the <code class=\"language-none\">atMousePosition</code> property may no longer be defined:"
            },
            {
                "style": "Text",
                "text": "<code class=\"language-js\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "    \"opacity\": 0.55,"
            },
            {
                "style": "Text",
                "text": "    \"lineWidth\": 1,"
            },
            {
                "style": "Text",
                "text": "    \"lineDash\": [0,0],"
            },
            {
                "style": "Text",
                "text": "    \"paletteColor\": \"UI_COLOR.RED\""
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            }
        ],
        "starting": []
    },
    {
        "type": "Style",
        "definition": "A style is a definition of color and opacity in case of a polygon body, and color, opacity and line thickness in case of polygon borders.",
        "content": [
            {
                "style": "Text",
                "text": "A style applied to a polygon body or a polygon border node acts as the default style. Styles including colors, opacity, line width, and more, are defined in the node's configuration."
            },
            {
                "style": "Note",
                "text": "See the configuration for further details."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a style, select <i>Add Style</i> on a polygon border or polygon body node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure Style</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "A typical definition for a polygon <i>body style</i> looks like this:"
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "    \"default\": {"
            },
            {
                "style": "Text",
                "text": "        \"opacity\": 0.2,"
            },
            {
                "style": "Text",
                "text": "        \"paletteColor\": \"UI_COLOR.DARK_TURQUOISE\""
            },
            {
                "style": "Text",
                "text": "    },"
            },
            {
                "style": "Text",
                "text": "    \"atMousePosition\": {"
            },
            {
                "style": "Text",
                "text": "        \"opacity\": 0.3,"
            },
            {
                "style": "Text",
                "text": "        \"paletteColor\": \"UI_COLOR.DARK_TURQUOISE\""
            },
            {
                "style": "Text",
                "text": "    }"
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "A typical definition for a polygon <i>border style</i> has a couple more properties:"
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "    \"default\": {"
            },
            {
                "style": "Text",
                "text": "        \"opacity\": 0.2,"
            },
            {
                "style": "Text",
                "text": "        \"lineWidth\": 1,"
            },
            {
                "style": "Text",
                "text": "        \"lineDash\": [0,0],"
            },
            {
                "style": "Text",
                "text": "        \"paletteColor\": \"UI_COLOR.DARK_TURQUOISE\""
            },
            {
                "style": "Text",
                "text": "    },"
            },
            {
                "style": "Text",
                "text": "    \"atMousePosition\": {"
            },
            {
                "style": "Text",
                "text": "        \"opacity\": 0.3,"
            },
            {
                "style": "Text",
                "text": "        \"lineWidth\": 2,"
            },
            {
                "style": "Text",
                "text": "        \"lineDash\": [0,0],"
            },
            {
                "style": "Text",
                "text": "        \"paletteColor\": \"UI_COLOR.RUSTED_RED\""
            },
            {
                "style": "Text",
                "text": "    }"
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "The first section of the definition refers, as explicitly stated, to the default state of the style."
            },
            {
                "style": "Text",
                "text": "The second section refers to the style assigned to the column or period on which the mouse pointer is located. This is very useful for highlighting the specific zone of interest as the user browses the charts."
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">opacity</code> is probably self-explanatory: it may range from <code class=\"language-none\">0<code class=\"language-none\"> for a fully transparent object to </code>1</code> for a solid object.</li>"
            },
            {
                "style": "Text",
                "text": "</ul>"
            },
            {
                "style": "Text",
                "text": "<table class=\"docs-table\"><tr><td> Variable Value </td><td> RGB Value </td><td> Color Sample </td></tr>"
            },
            {
                "style": "Text",
                "text": "<tr><td> :--- </td><td> :---: </td><td> :------------------- </td></tr>"
            },
            {
                "style": "Text",
                "text": "<tr><td> <code class=\"language-none\">DARK</code> </td><td> 48, 48, 54 </td><td> <span style=\"display: block; background: RGB(48, 48, 54); border: 1px solid black;\">&nbsp;</span> </td></tr>"
            },
            {
                "style": "Text",
                "text": "<tr><td> <code class=\"language-none\">LIGHT</code> </td><td> 234, 226, 222 </td><td> <span style=\"display: block; background: RGB(234, 226, 222); border: 1px black; border: 1px solid black;\">&nbsp;</span> </td></tr>"
            },
            {
                "style": "Text",
                "text": "<tr><td> <code class=\"language-none\">GREY</code> </td><td> 150, 150, 150 </td><td> <span style=\"display: block; background: RGB(150, 150, 150); border: 1px solid black;\">&nbsp;</span> </td></tr>"
            },
            {
                "style": "Text",
                "text": "<tr><td> <code class=\"language-none\">LIGHT_GREY</code> </td><td> 247, 247, 247 </td><td> <span style=\"display: block; background: RGB(247, 247, 247); border: 1px solid black;\">&nbsp;</span> </td></tr>"
            },
            {
                "style": "Text",
                "text": "<tr><td> <code class=\"language-none\">WHITE</code> </td><td> 255, 255, 255 </td><td> <span style=\"display: block; background: RGB(255, 255, 255); border: 1px solid black;\">&nbsp;</span> </td></tr>"
            },
            {
                "style": "Text",
                "text": "<tr><td> <code class=\"language-none\">BLACK</code> </td><td> 0, 0, 0 </td><td> <span style=\"display: block; background: RGB(0, 0, 0); border: 1px solid black;\">&nbsp;</span> </td></tr>"
            },
            {
                "style": "Text",
                "text": "<tr><td> <code class=\"language-none\">GOLDEN_ORANGE</code> </td><td> 240, 162, 2 </td><td> <span style=\"display: block; background: RGB(240, 162, 2); border: 1px solid black;\">&nbsp;</span> </td></tr>"
            },
            {
                "style": "Text",
                "text": "<tr><td> <code class=\"language-none\">RUSTED_RED</code> </td><td> 204, 88, 53 </td><td> <span style=\"display: block; background: RGB(204, 88, 53); border: 1px solid black;\">&nbsp;</span> </td></tr>"
            },
            {
                "style": "Text",
                "text": "<tr><td> <code class=\"language-none\">GREEN</code> </td><td> 188, 214, 67 </td><td> <span style=\"display: block; background: RGB(188, 214, 67); border: 1px solid black;\">&nbsp;</span> </td></tr>"
            },
            {
                "style": "Text",
                "text": "<tr><td> <code class=\"language-none\">RED</code> </td><td> 223, 70, 60 </td><td> <span style=\"display: block; background: RGB(223, 70, 60); border: 1px solid black;\">&nbsp;</span> </td></tr>"
            },
            {
                "style": "Text",
                "text": "<tr><td> <code class=\"language-none\">PATINATED_TURQUOISE</code> </td><td> 27, 153, 139 </td><td> <span style=\"display: block; background: RGB(27, 153, 139); border: 1px solid black;\">&nbsp;</span> </td></tr>"
            },
            {
                "style": "Text",
                "text": "<tr><td> <code class=\"language-none\">TITANIUM_YELLOW</code> </td><td> 244, 228, 9 </td><td> <span style=\"display: block; background: RGB(244, 228, 9); border: 1px solid black;\">&nbsp;</span> </td></tr>"
            },
            {
                "style": "Text",
                "text": "<tr><td> <code class=\"language-none\">MANGANESE_PURPLE</code> </td><td> 91,80, 122 </td><td> <span style=\"display: block; background: RGB(91,80, 122); border: 1px solid black;\">&nbsp;</span> </td></tr>"
            },
            {
                "style": "Text",
                "text": "<tr><td> <code class=\"language-none\">TURQUOISE</code> </td><td> 74, 207, 217 </td><td> <span style=\"display: block; background: RGB(74, 207, 217); border: 1px solid black;\">&nbsp;</span> </td></tr>"
            },
            {
                "style": "Text",
                "text": "<tr><td> <code class=\"language-none\">DARK_TURQUOISE</code> </td><td> 2, 149, 170 </td><td> <span style=\"display: block; background: RGB(2, 149, 170); border: 1px solid black;\">&nbsp;</span> </td></tr>"
            },
            {
                "style": "Text",
                "text": "</table>* <code class=\"language-none\">lineWidth</code> is the width of the border line, which should be greater than 0."
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">lineDash</code> is used to turn the border into a dashed-line; the first value corresponds to the length of the dash while the second value defines the length of the space.</li>"
            },
            {
                "style": "Note",
                "text": "</ul>"
            }
        ],
        "starting": []
    },
    {
        "type": "Polygon Vertex",
        "definition": "A polygon vertex is a reference to a point defined in the chart points, constituting a specific coordinate to be used as a vertex of a shape.",
        "content": [
            {
                "style": "Text",
                "text": "Vertices are the main element defining polygons. Once created, each vertex must establish a reference to the corresponding point in the charts point."
            },
            {
                "style": "Text",
                "text": "<img src=\"Projects/Superalgos/Docs-Gifs/vertex-01-add-and-link.gif\"></img>"
            },
            {
                "style": "Text",
                "text": "Drawing curves requires two vertices. Painting areas, such as the background of a chart, likely requires four vertices. Note that vertices are not capable of featuring a style. Instead, styles are applied to polygon borders and polygon bodies."
            },
            {
                "style": "Important",
                "text": "Bear in mind that the order in which vertices in a polygon are arranged around the parent polygon node when their <i>rotational symmetry</i> property is selected, is the order in which the plotter computes the points. This means that points need to be in the correct order, for example, when drawing a box. Imagine drawing a box on a piece of paper without lifting the pencil... that is how the plotter does it."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a polygon vertex, select <i>Add Polygon Vertex</i> on the polygon node menu."
            },
            {
                "style": "Text",
                "text": "{% include tip.html content=\"Remember that a vertex must establish a reference to a point in the charts point to be properly defined\" %}"
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Situation",
        "definition": "A situation refers to a specific state of the market in which a certain event should take place, as defined by any number of conditions.",
        "content": [
            {
                "style": "Text",
                "text": "In other words, you define situations in which you wish a certain event to happen (<i>i.e.:</i> trigger on the strategy, take a position, etc.) and each situation is described as a set of conditions that need to be met for the event to be triggered."
            },
            {
                "style": "Text",
                "text": "A situation gets validated when all conditions under it are true."
            },
            {
                "style": "Text",
                "text": "An event may have more than one situation attached to it. In such a case, when any of the situations gets validated, the event gets triggered. That is, events may be triggered in different circumstances, meaning that you are free to define different situations upon which the same event would be triggered. In such a case, when any of the situations evaluate true, then the event is triggered."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a situation, select <i>Add Situation</i> on the corresponding event node menu. A situation is added along with a condition and JavaScript code node."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Condition",
        "definition": "Conditions are rules within a situation. When all conditions under a situation validate true, then the situation gets validated as well, and the associated event is triggered.",
        "content": [
            {
                "style": "Text",
                "text": "Therefore, conditions are used to mathematically describe what needs to happen with the market for a certain action to be taken."
            },
            {
                "style": "Text",
                "text": "<b>For example:</b>"
            },
            {
                "style": "Text",
                "text": "<b>Situation 1</b>"
            },
            {
                "style": "Text",
                "text": "<ul><li>Condition A: <code class=\"language-none\">chart.at01hs.candle.close > chart.at01hs.bollingerBand.MovingAverage</code> &#8594; This means that the latest candle at the 1 hour chart closed above the Bollinger Bands moving average.</li>"
            },
            {
                "style": "Text",
                "text": "<li>Condition B: <code class=\"language-none\">chart.at01hs.candle.previous.max > chart.at01hs.bollingerBand.previous.MovingAverage</code> &#8594; This means that the maximum value of the candle before the last one, was higher than the Bollinger Bands moving average.</li>"
            },
            {
                "style": "Text",
                "text": "</ul>"
            },
            {
                "style": "Text",
                "text": "In the example above, conditions A and B are comparison statements that may evaluate either _true_ or _false_. In the case both would evaluate _true_ then Situation 1 would be true as well."
            },
            {
                "style": "Note",
                "text": "To learn how to write conditions, start with the Syntax Overview."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a condition, select <i>Add Condition</i> on the corresponding situation node menu. A condition with its JavaScript code node is added."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Super Scripts",
        "definition": "The super scripts hierarchy holds definitions of scripts used to automate certain aspects of the administration and maintenance of the workspace, such as installing and deleting markets.",
        "content": [
            {
                "style": "Text",
                "text": "The super scripts hierarchy may be used by developers who wish to create their own scripts for automating the deployment or manitenance of all sorts of structures of nodes across any of the hierarchies in the design space."
            },
            {
                "style": "Text",
                "text": "Regular users will find little to do with this hierarchy, even though they may use it indirectly, for instance, when installing or uninstalling markets."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a super scripts hierarchy, select <i>Add Super Scripts</i> on the other hierarchies node menu in the Superalgos Project hierarchy."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure Super Scripts</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-none\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "\"codeName\": \"Masters\""
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code>"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">codeName</code> is the name of the hierarchy as is used in the system's code.</li></ul>"
            }
        ],
        "starting": []
    },
    {
        "type": "Scripts Library",
        "definition": "A script library is a collection of related scripts.",
        "content": [
            {
                "style": "Text",
                "text": "The script library node plays an organizational role, grouping masters scripts according to the criteria of the developer."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a scripts library, select <i>Add Scripts Library</i> on the super scripts node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Master Script",
        "definition": "A master script contains the definitions of any number of template scripts along with the master JavaScript code providing the logic to implement them.",
        "content": [
            {
                "style": "Text",
                "text": "In general terms, master scripts serve to atomize the complexity of the task at hand by subdividing the task into any number of specific scopes, handled by individual template scripts. The master script controls the execution of template scripts and solves issues beyond their scope."
            },
            {
                "style": "Text",
                "text": "The current implementation of the Masters super scripts hierarchy features two master scripts you may use as examples. The Setup Market master script deals with all the steps required to install a new market, while the Delete Market Dependencies master script deals with uninstalling markets."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a master script, select <i>Add Master Script</i> on the scripts library node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Template Script",
        "definition": "The template script node holds the definitions concerned with the scope of a particular structure of nodes.",
        "content": [
            {
                "style": "Text",
                "text": "As such, a template script features all the components required to deal with such scope only."
            },
            {
                "style": "Text",
                "text": "In the particular Masters super script implementation, each template script in the Setup Markets master script features a structure of nodes to be created in a specific location, and the associated JavaScript code deals with implementing such structure of nodes and establishing the corresponding references."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a template script, select <i>Add Template Script</i> on the scripts master script node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Template Structure",
        "definition": "The template structure holds the structure of nodes with all its configurations and properties, exactly as it should be implemented.",
        "content": [
            {
                "style": "Text",
                "text": "Properties include the physical arrangement of nodes, references and so on."
            },
            {
                "style": "Note",
                "text": "The actual structure of nodes contained in the template usually originates as a clone of an existing structure of nodes."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a tempalte strucutre, select <i>Add Teemplate Structure</i> on the template script node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Template Target",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add a template target, select <i>Add Template Target</i> on the template script node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Super Action"
    },
    {
        "type": "Network",
        "definition": "The network hierarchy provides the control functions for running data-mining and trading operations. Because operations may be run either on a single machine or distributed over a network of machines, it also contains definitions regarding the physical location in which nodes live or function.",
        "content": [
            {
                "style": "Text",
                "text": "The network hierarchy defines where in the network you run each of the bots you choose to run, and where the data they output is stored."
            },
            {
                "style": "Text",
                "text": "You will use the network hierarchy for the following purposes:"
            },
            {
                "style": "Text",
                "text": "<ul><li>To control your data mining operation&mdash;that is, tasks running sensor and indicator bots. Data mining tasks process data that may be consumed by others; for example, so that your trading systems may count with quality information.</li>"
            },
            {
                "style": "Text",
                "text": "<li>To control your testing environment&mdash;that is, trading sessions including backtesting and paper trading sessions.</li>"
            },
            {
                "style": "Text",
                "text": "<li>To control your production environment&mdash;that is, forward testing, and live trading sessions.</li>"
            },
            {
                "style": "Text",
                "text": "<li>To manage the storage of the data produced by the bots you run as outputs. This includes administering the physical locations on which the data products produced by bots reside.</li>"
            },
            {
                "style": "Warning",
                "text": "At this stage, the system does not implement any form of security measures, therefore, Superalgos is to be run in the context of a restricted Local Area Network only, unless you implement your own network security."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a network, select <i>Add Network</i> on the other hierarchies node menu in the Superalgos Project hierarchy."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Network Node",
        "definition": "A network node represents a machine running Superalgos, on which processes run and data is stored.",
        "content": [
            {
                "style": "Text",
                "text": "By default, processes are set up to run locally in a network node representing your local machine. However, the system is prepared to run distributed on a network of nodes, or what we call a trading farm."
            },
            {
                "style": "Text",
                "text": "You may create unlimited network nodes and map them with different machines on a network. Each machine in the network runs an instance of the Superalgos backend, and you may control the whole network operation from a single machine, or&mdash;in general&mdash;from any machine in the network running the Superalgos frontend. To learn more about distributed setups, check the trading farms pages."
            },
            {
                "style": "Text",
                "text": "The easiest and fastest way to set up a network node is using the <i>Install Market</i> function available on markets defined in the Crypto Ecosystem hierarchy, under the exchange markets node. This function adds data mining tasks for all sensor and indicator bots shipping with the system, backtesting and live trading tasks for trading systems shipping with the system, including the data storage definitions for both, and also creates the corresponding dashboards and charts in the Charting Space hierarchy. You may learn more about this function in the how to install a new market page."
            },
            {
                "style": "Text",
                "text": "If you need finer control over the operation you wish to deploy on the network, then you may use the individual functions available under each section of the hierarchy under the network node."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a network node, select <i>Add Network Node</i> on the <i>Superalgos Network</i> node menu. A network node is added along with the basic structure of nodes to set up a node."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "\"host\": \"localhost\","
            },
            {
                "style": "Text",
                "text": "\"webPort\": \"34248\","
            },
            {
                "style": "Text",
                "text": "\"webSocketsPort\": \"18041\""
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">host</code> is the machine or hardware represented by the network node. The default parameter is <code class=\"language-none\">localhost<code class=\"language-none\">, but if you intend to access the backend services of this node from a remote computer, then you must change </code>localhost</code> for the IP Address of the machine on which the node is running, for example, to <code class=\"language-none\">147.0.0.1</code>.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">webPort</code> is the port used by the Web Server, at this stage <code class=\"language-none\">34248</code>.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">webSocketsPort</code> is the port used by the system to communicate over the local area network, by default set at <code class=\"language-none\">18041</code>.</li></ul>"
            }
        ],
        "starting": []
    },
    {
        "type": "Task Manager",
        "definition": "A task manager is a device used to organize and control any number of tasks, which, in turn, control bot instances. You use a task manager to start or stop several tasks at the same time.",
        "content": [
            {
                "style": "Text",
                "text": "Task managers are used both in the context of data mining and trading operations, to facilitate the organization of tasks."
            },
            {
                "style": "Text",
                "text": "For example, you may set up a task manager to handle tasks related to a particular set of indicators used with a certain strategy. Or, for example, to organize multiple backtesting sessions."
            },
            {
                "style": "Text",
                "text": "{% include tip.html content=\"The key aspect of a task manager is that it allows starting and stopping all tasks at once.\" %}"
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a task manager, select <i>Add Task Manager</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": [
            {
                "style": "Text",
                "text": "Select <i>Run All Tasks</i> or <i>Stop All Tasks</i> on the menu to start and stop all tasks respectively."
            }
        ]
    },
    {
        "type": "Task",
        "definition": "A task is the device used to control bot instances, that is, to start and stop bots, including sensors, indicators and the trading bot.",
        "content": [
            {
                "style": "Text",
                "text": "Each task controls a single bot. A bot instance running on its own task is independent from other bots at the operating system level, thus, may not be affected by errors ocurring on those other bots."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a task, select <i>Add Task</i> on the task manager node menu."
            },
            {
                "style": "Text",
                "text": "{% include tip.html content=\"Instead of adding nodes, configuring them, and setting references one by one, you may want to clone an existing, fully functional task with all its offspring.\" %}"
            }
        ],
        "configuring": [],
        "starting": [
            {
                "style": "Text",
                "text": "Select <i>Run</i> on the menu to start a task. When a task is started, the process instance of the bot instance attached to the task is started. Also, a visual indication that both the task and the process instance are running appear surrounding the corresponding nodes, in the form of a progress ring."
            },
            {
                "style": "Text",
                "text": "To stop a task, select <i>Stop</i> on the menu."
            }
        ]
    },
    {
        "type": "Trading Bot Instance",
        "definition": "A trading bot instance is a reference to the trading bot as defined in the Masters data mine. The instance of the bot runs the defined processes and generates the defined data products.",
        "content": [
            {
                "style": "Text",
                "text": "{{site.data.concepts.trading_bot}}"
            },
            {
                "style": "Text",
                "text": "The trading bot instance holds no definitions as to what the bot does. Instead, its process instance references the process definition in the Masters data mine. That is how the indicator bot instance obtains the information of what it needs to do once it is run."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a trading bot instance, select <i>Add Trading Bot Instance</i> on the task node menu. When a trading bot instance is added, it is created with one trading process instance, and a market reference."
            }
        ],
        "configuring": [],
        "starting": [
            {
                "style": "Text",
                "text": "You do not start or stop a trading bot instance directly. Instead, you start or stop the corresponding task."
            }
        ]
    },
    {
        "type": "Learning Bot Instance"
    },
    {
        "type": "Sensor Process Instance",
        "definition": "A sensor process instance is a reference to the process definition of a sensor bot, as defined in a data mine.",
        "content": [
            {
                "style": "Text",
                "text": "For example, in the case of an instance of the Masters data mine Exchange Raw Data sensor bot, the bot process instance references the <i>Historic OHLCVs</i> process definition. Once the reference is established, the sensor process instance adopts the name of the process definition it references."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a sensor process instance, select <i>Add Sensor Process Instance</i> on the sensor bot instance node menu."
            }
        ],
        "configuring": [],
        "starting": [
            {
                "style": "Text",
                "text": "You do not start or stop a sensor process instance directly. Instead, you start or stop the corresponding task."
            }
        ]
    },
    {
        "type": "Indicator Process Instance",
        "definition": "An indicator process instance is a reference to the process definition of an indicator bot, as defined in a data mine.",
        "content": [
            {
                "style": "Text",
                "text": "Indicator bot instances usually require two indicator process instances. One of them references the indicator's <i>multi-period-market</i> process definition and the second references the <i>multi-period-daily</i> process definition."
            },
            {
                "style": "Text",
                "text": "Once the reference is established, the indicator process instance adopts the name of the process definition it references."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add an indicator process instance, select <i>Add Indicator Process Instance</i> on the indicator bot instance node menu."
            }
        ],
        "configuring": [],
        "starting": [
            {
                "style": "Text",
                "text": "You do not start or stop an indicator process instance directly. Instead, you start or stop the corresponding task."
            }
        ]
    },
    {
        "type": "Trading Process Instance",
        "definition": "A trading process instance is a reference to the process definition of the trading bot, as defined in the Masters data mine.",
        "content": [
            {
                "style": "Text",
                "text": "The trading process instance must reference the <i>Multi-Period</i> process definition of the Jason trading bot in the Masters data mine."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a trading process instance, select <i>Add Trading Process Instance</i> on the trading bot instance node menu. When a trading process instance is added, it is created with a market reference."
            },
            {
                "style": "Note",
                "text": "After adding a trading process instance node, make sure you establish the reference to the <i>Multi-Period</i> process definition of the Jason trading bot in the Masters data mine."
            }
        ],
        "configuring": [],
        "starting": [
            {
                "style": "Text",
                "text": "You do not start or stop a trading process instance directly. Instead, you start or stop the corresponding task."
            }
        ]
    },
    {
        "type": "Learning Process Instance"
    },
    {
        "type": "Backtesting Session",
        "definition": "A backtesting session is a trading mode by which the trading bot instance reads historic market data in a user-defined datetime range, applies the rules defined in the associated trading system, and generates a trading simulation.",
        "content": [
            {
                "style": "Text",
                "text": "A backtesting session node must reference a trading system to gain access to the trading logic to be applied during the session. Other considerations framing the session come from the set of parameters attached to it."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a backtesting session, select <i>Add Backtesting Session</i> on the trading process instance node menu. When a session is added, it is created with the full set of parameters."
            },
            {
                "style": "Note",
                "text": "After adding a session node, make sure you establish a reference to the trading system you want it to work with."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure Session</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "\"folderName\": \"Session-Name\""
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">folderName</code> allows you to set a significant name to the folder in which the data products&mdash;and logs&mdash;generated by the session are stored. If left blank, the system names the folders with the session id. This may be handy when you intend to consult the raw data generated by the session, as, otherwise, the folder would be hard to identify.</li></ul>"
            }
        ],
        "starting": [
            {
                "style": "Text",
                "text": "Before you start a backtesting session, the corresponding task needs to be running, as it is the task that puts the trading bot instance to run. Once the trading bot instance is running, select <i>Run</i> on the menu to start the session."
            },
            {
                "style": "Text",
                "text": "After a few seconds, a literal indication of the progress of the calculations appears below the session node, displaying the date that is currently being processed. Once the calculation is finished, the session stops and the date below the session node dissapears."
            },
            {
                "style": "Text",
                "text": "To stop a backtesting session, select <i>Stop</i> on the menu."
            }
        ]
    },
    {
        "type": "Trading Engine",
        "definition": "The trading engine hierarchy is the data structure used by the trading bot to keep runtime information highly accessible and exposed to others.",
        "content": [
            {
                "style": "Text",
                "text": "You will use this hierarchy for two main purposes:"
            },
            {
                "style": "Text",
                "text": "<ul><li><b>To let your trading systems access the information processed by the trading bot.</b> This allows strategies to keep track of and react to current and past events&mdash;including those involving the exchange, such as orders placed or filled&mdash;as the bot is running.</li>"
            },
            {
                "style": "Text",
                "text": "<li><b>To keep track of the actions of the trading bot via the design space visual environment and panels over the charts.</b> By analyzing runtime information, you may gain a detailed understanding of what happens, when, and why, throughout a trading session.</li>"
            },
            {
                "style": "Text",
                "text": "</ul>"
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "{% include tip.html content=\"There may be more than one trading engine in a workspace. Cloning the default trading engine is the best way to start a new one.\" %}"
            },
            {
                "style": "Text",
                "text": "To add the trading engine node from scratch, select <i>Add Trading Engine</i> on the other hierarchies node menu in the Superalgos Project hierarchy."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Dynamic Indicators",
        "definition": "",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the dynamic indicators node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Indicator Function",
        "definition": "",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the indicator function node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Episode",
        "definition": "Episode is the object that handles the information corresponding to the whole run of the trading bot&mdash;beginning to end&mdash;between the specified initial datetime and final datetime, in the time range parameter of the trading session.",
        "content": [
            {
                "style": "Text",
                "text": "In other words, episode is the context framed between the datetimes that make up the whole trading session, as per the session's configuration. As such, an episode keeps track of&mdash;and accumulates&mdash;the results of all positions entered throughout a complete run of a trading session."
            },
            {
                "style": "Text",
                "text": "In this section of the hierarchy, you have access to:"
            },
            {
                "style": "Text",
                "text": "<ul><li> <b>running balances and overall performance metrics</b> denominated in both the base and quoted assets;</li>"
            },
            {
                "style": "Text",
                "text": "<li><b>counters</b>, such as the number of positions taken, orders placed, hits, fails, and so on;</li>"
            },
            {
                "style": "Text",
                "text": "<li><b>statistics</b>, such as performance metrics consolidating both assets, number of days in the episode, or user-defined statistics;</li>"
            },
            {
                "style": "Text",
                "text": "<li><b>the distance to certain events</b>, such as the number of candles to the last  take position event, or the last create order event;</li>"
            },
            {
                "style": "Text",
                "text": "<li><b>rates describing each candle</b> in the episode, such as the open, close, min and max rates;</li></ul>"
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the episode node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Episode Counters",
        "definition": "The episode counters node features counters of instances of objects that come to exist during the duration of the episode.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the episode counters node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Position Counters",
        "definition": "The position counters node features counters of instances of objects that come to exist during the duration of the position.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the position counters node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Strategy Counters",
        "definition": "The strategy counters node features counters of instances of objects that come to exist while the strategy is open.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the strategy counters node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Order Counters",
        "definition": "The order counters node features counters of instances of objects that come to exist while the order is open.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the order counters node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Positions",
        "definition": "Positions counts the number of times positions have been opened, in the context of the parent node.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the positions node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Strategies",
        "definition": "Strategies counts the number of times strategies have been triggered-on, in the context of the parent node.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the strategies node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Orders",
        "definition": "Orders counts the number of times orders have been placed, in the context of the parent node.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the orders node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Fails",
        "definition": "Fails counts the number of positions that closed with a negative profit loss, in the context of the parent node.",
        "content": [
            {
                "style": "Note",
                "text": "The workings of the fail counts are analogous to the workings of the hits counts, reversing the sign. That is, when profit loss is negative, it is counted as a fail. Please refer to the definition of <i>hits</i> for the details."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the fails node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Hits",
        "definition": "Hits counts the number of positions that closed with a positive profit loss, in the context of the parent node.",
        "content": [
            {
                "style": "Text",
                "text": "In the context of the quoted asset or the base asset, <i>hits</i> are calculated relative to the asset in question. That is, if the base asset profit loss is positive, then a hit is counted for the base asset."
            },
            {
                "style": "Text",
                "text": "However, when the context of the asset is not specified&mdash;such as under the statistics node&mdash;then <i>hits</i> are calculated in a consolidated manner, converting the respective balances to perform the calculations."
            },
            {
                "style": "Note",
                "text": "The consolidated calculations are explained thoroughly in the profit loss node."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the hits node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Periods",
        "definition": "Periods counts the number of candles that have been evaluated, in the context of the parent node.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the periods node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "User Defined Counter",
        "definition": "",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the user defined counter node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Episode Statistics",
        "definition": "Episode statistics keeps track of several metrics in the context of the episode.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the episode statistics node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Stop Loss",
        "definition": "Stop loss is the current stop loss target, as defined in the manage stage of the corresponding strategy.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the stop loss node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Take Profit",
        "definition": "Take profit is the current take profit target, as defined in the manage stage of the corresponding strategy.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the take profit node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Initial Value"
    },
    {
        "type": "Final Value"
    },
    {
        "type": "Stop Loss Phase",
        "definition": "Stop loss phase is the numeric value of the phase that is currently open, and thus, defining the value of the stop loss.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the stop loss phase node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Take Profit Phase",
        "definition": "Take profit phase is the numeric value of the phase that is currently open, and thus, defining the value of the take profit.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the take profit phase node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Take Profit Position",
        "definition": "Take profit position indicates if the take profit target is above or below the position rate.",
        "content": [
            {
                "style": "Text",
                "text": "Possible values are <code class=\"language-none\">Above</code> and <code class=\"language-none\">Below</code>."
            },
            {
                "style": "Text",
                "text": "The implications of setting the take profit target above or below the position rate are explained on the trading system section of the documentation, in particular while describing the initial target rate definition."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the take profit position node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Stop Loss Position",
        "definition": "Stop Loss position indicates if the stop loss target is above or below the position rate.",
        "content": [
            {
                "style": "Text",
                "text": "Possible values are <code class=\"language-none\">Above</code> and <code class=\"language-none\">Below</code>."
            },
            {
                "style": "Text",
                "text": "The implications of setting the stop loss target above or below the position rate are explained on the trading system section of the documentation, in particular while describing the initial target rate definition."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the stop loss position node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Position Statistics",
        "definition": "Position statistics keeps track of several metrics in the context of the position.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the position statistics node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Stage Base Asset",
        "definition": "The stage base asset node keeps track of the evolution of variables related to the base asset throughout the stage.",
        "content": [
            {
                "style": "Note",
                "text": "Learn more about how accounts for the base asset and the quoted asset are kept in the base asset and quoted asset page on the trading engine section of the documentation."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the stage base asset node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Stage Quoted Asset",
        "definition": "The stage quoted asset node keeps track of the evolution of variables related to the quoted asset throughout the stage.",
        "content": [
            {
                "style": "Note",
                "text": "Learn more about how accounts for the base asset and the quoted asset are kept in the base asset and quoted asset page on the trading engine section of the documentation."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the stage quoted asset node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Episode Base Asset",
        "definition": "The episode base asset node keeps track of the evolution of variables and metrics denominated in the base asset, throughout the episode.",
        "content": [
            {
                "style": "Note",
                "text": "Learn more about how accounts for the base asset and the quoted asset are kept in the base asset and quoted asset page on the trading engine section of the documentation."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the episode base asset node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Episode Quoted Asset",
        "definition": "The episode quoted asset node keeps track of the evolution of variables and metrics denominated in the quoted asset, throughout the episode.",
        "content": [
            {
                "style": "Note",
                "text": "Learn more about how accounts for the base asset and the quoted asset are kept in the base asset and quoted asset page on the trading engine section of the documentation."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the episode quoted asset node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Position Base Asset",
        "definition": "The position base asset node keeps track of the evolution of variables related to the base asset throughout the position.",
        "content": [
            {
                "style": "Note",
                "text": "Learn more about how accounts for the base asset and the quoted asset are kept in the base asset and quoted asset page on the trading engine section of the documentation."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the position base asset node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Position Quoted Asset",
        "definition": "The position quoted asset node keeps track of the evolution of variables related to the quoted asset throughout the position.",
        "content": [
            {
                "style": "Note",
                "text": "Learn more about how accounts for the base asset and the quoted asset are kept in the base asset and quoted asset page on the trading engine section of the documentation."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the position quoted asset node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Order Statistics",
        "definition": "Order statistics keeps track of several metrics in the context of the order.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the order statistics node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Order Base Asset",
        "definition": "The order base asset node keeps track of the evolution of certain properties of orders, denominated in the base asset.",
        "content": [
            {
                "style": "Note",
                "text": "Learn more about how accounts for the base asset and the quoted asset are kept in the base asset and quoted asset page on the trading engine section of the documentation."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the order base asset node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Order Quoted Asset",
        "definition": "The order quoted asset node keeps track of the evolution of certain properties of orders, denominated in the quoted asset.",
        "content": [
            {
                "style": "Note",
                "text": "Learn more about how accounts for the base asset and the quoted asset are kept in the base asset and quoted asset page on the trading engine section of the documentation."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the order quoted asset node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "User Defined Statistic",
        "definition": "A user defined statistic allows users to create custom metrics by defining the corresponding calculation in a formula, in the context of the parent node.",
        "content": [
            {
                "style": "Text",
                "text": "The current contexts in which custom statistics may be defined are episodes, positions, and orders."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the user defined statistic node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Profit Loss",
        "definition": "Profit loss is the difference between the balance at the end and the balance at the beginning of a certain period, given by the context.",
        "content": [
            {
                "style": "Text",
                "text": "In the context of the base asset or the quoted asset, the calculation is done by subtracting the balances in the corresponding assets, using the variable appropriate to the larger context (i.e.: episode, position, etc.)."
            },
            {
                "style": "Text",
                "text": "<i>In general terms:</i>"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">base asset profit loss = base asset end balance - base asset begin balance</code></li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">quoted asset profit loss = quoted asset end balance - quoted asset begin balance</code></li>"
            },
            {
                "style": "Text",
                "text": "</ul>"
            },
            {
                "style": "Text",
                "text": "<code class=\"language-none\">"
            },
            {
                "style": "Text",
                "text": "tradingEngine.current.episode.episodeBaseAsset.profitLoss.value ="
            },
            {
                "style": "Text",
                "text": "    tradingEngine.current.episode.episodeBaseAsset.balance.value -"
            },
            {
                "style": "Text",
                "text": "    sessionParameters.sessionBaseAsset.config.initialBalance"
            },
            {
                "style": "Text",
                "text": "   "
            },
            {
                "style": "Text",
                "text": "tradingEngine.current.episode.episodeQuotedAsset.profitLoss.value ="
            },
            {
                "style": "Text",
                "text": "    tradingEngine.current.episode.episodeQuotedAsset.balance.value -"
            },
            {
                "style": "Text",
                "text": "    sessionParameters.sessionQuotedAsset.config.initialBalance"
            },
            {
                "style": "Text",
                "text": "</code>"
            },
            {
                "style": "Text",
                "text": "<i>In the case of the position base asset and position quoted asset:</i>"
            },
            {
                "style": "Text",
                "text": "<code class=\"language-none\">"
            },
            {
                "style": "Text",
                "text": "tradingEngine.current.position.positionBaseAsset.profitLoss.value ="
            },
            {
                "style": "Text",
                "text": "    tradingEngine.current.episode.episodeBaseAsset.balance.value -"
            },
            {
                "style": "Text",
                "text": "    tradingEngine.current.position.positionBaseAsset.beginBalance"
            },
            {
                "style": "Text",
                "text": "   "
            },
            {
                "style": "Text",
                "text": "tradingEngine.current.position.positionQuotedAsset.profitLoss.value ="
            },
            {
                "style": "Text",
                "text": "    tradingEngine.current.episode.episodeQuotedAsset.balance.value -"
            },
            {
                "style": "Text",
                "text": "    tradingEngine.current.position.positionQuotedAsset.beginBalance"
            },
            {
                "style": "Text",
                "text": "</code>"
            },
            {
                "style": "Text",
                "text": "In the context of the episode statistics or the position statistics, the calculation is done consolidating the profits of both assets."
            },
            {
                "style": "Note",
                "text": "When the context does not refer to either of the assets in particular, then both assets are taken into account in the calculation."
            },
            {
                "style": "Text",
                "text": "<i>In the context of the episode statistics:</i>"
            },
            {
                "style": "Text",
                "text": "<code class=\"language-none\">"
            },
            {
                "style": "Text",
                "text": "tradingEngine.current.episode.episodeStatistics.profitLoss.value ="
            },
            {
                "style": "Text",
                "text": "    tradingEngine.current.episode.episodeBaseAsset.profitLoss.value *"
            },
            {
                "style": "Text",
                "text": "    tradingEngine.current.episode.candle.close.value +"
            },
            {
                "style": "Text",
                "text": "    tradingEngine.current.episode.episodeQuotedAsset.profitLoss.value"
            },
            {
                "style": "Text",
                "text": "</code>"
            },
            {
                "style": "Text",
                "text": "<i>In the context of the position statistics:</i>"
            },
            {
                "style": "Text",
                "text": "<code class=\"language-none\">"
            },
            {
                "style": "Text",
                "text": "tradingEngine.current.position.positionStatistics.profitLoss.value ="
            },
            {
                "style": "Text",
                "text": "    tradingEngine.current.episode.episodeBaseAsset.profitLoss.value *"
            },
            {
                "style": "Text",
                "text": "    tradingEngine.current.position.endRate.value +"
            },
            {
                "style": "Text",
                "text": "    tradingEngine.current.episode.episodeQuotedAsset.profitLoss.value"
            },
            {
                "style": "Text",
                "text": "</code>"
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the profit loss node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Hit Ratio",
        "definition": "Hit ratio is the percentage of positions that closed with a positive profit loss, in the context of the parent node.",
        "content": [
            {
                "style": "Text",
                "text": "Hit ratio results from multiplying the number of hits by 100 and dividing it by the number of positions: <code class=\"language-none\">hit ratio = hits * 100 / positions</code>."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the hit ratio node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Days",
        "definition": "Days counts the number of days through which the trading bot has cycled since the object represented by the parent node was open.",
        "content": [
            {
                "style": "Text",
                "text": "In the context of an episode, it counts the number of days in the episode."
            },
            {
                "style": "Text",
                "text": "In the context of a position, it counts the number of days a position has been open."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the days node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Size Filled",
        "definition": "Size filled is the amount of the order that has been filled at the exchange.",
        "content": [
            {
                "style": "Text",
                "text": "In the context of a strategy stage, the size filled refers to the sum of the size filled for all orders placed on the corresponding stage."
            },
            {
                "style": "Text",
                "text": "In the context of an order, it refers to the size filled for the particular order."
            },
            {
                "style": "Text",
                "text": "Upon each execution of the trading bot, the system asks the exchange about the status of the orders placed, and the exchange reports back with the size filled and the actual rate at which orders are filled."
            },
            {
                "style": "Text",
                "text": "In liquid markets, market orders should usually fill immediately. However, limit orders may fill incrementally. Size filled keeps track of how much of the size placed has been filled on every execution."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the size filled node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Percentage Filled",
        "definition": "Percentage filled represents the portion of the order that has been filled, expressed as a percentage.",
        "content": [
            {
                "style": "Text",
                "text": "<i>The formula:</i>"
            },
            {
                "style": "Text",
                "text": "<code class=\"language-none\">percentage filled = size filled * 100 / size</code>"
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the percentage filled node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Actual Rate",
        "definition": "Actual rate is the number reported by the exchange as the rate at which an order was filled.",
        "content": [
            {
                "style": "Text",
                "text": "When the system consults the status of open orders with the exchange, the exchange responds with the size filled and the actual rate for the particular order. In case an order is filled incrementally, the value is updated accordingly."
            },
            {
                "style": "Text",
                "text": "The system uses the actual rate to update the calculation of balances, which are otherwise calculated with the original rate, by default."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the actual rate node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Fees Paid",
        "definition": "Fees paid is the amount paid in fees.",
        "content": [
            {
                "style": "Text",
                "text": "The exchange does not explicitly indicate how much has been paid in fees for a given transaction. Instead, when Superalgos verifies if an order has been filled or not, the exchange reports the size filled and the actual rate only."
            },
            {
                "style": "Success",
                "text": "Exchange fees are <i>estimated</i> using the <i>fee structure</i> parameter set for the trading session. It is, therefore, important to set the correct values for that parameter."
            },
            {
                "style": "Text",
                "text": "Exchanges deduct fees from the asset you are receiving. For instance, if you are selling BTC in the BTC-USDT market, then you are receiving USDT, and the exchange will deduct the fees directly from the amount of USDT you are receiving."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the fees paid node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "ROI",
        "definition": "ROI is a ratio that compares the profit loss with the cost of the investment, expressed as a percentage."
    },
    {
        "type": "Annualized Rate Of Return",
        "definition": "Annualized rate of return is the equivalent ROI scaled to one year.",
        "content": [
            {
                "style": "Text",
                "text": "In other words, it is the equivalent annual return received over a given period."
            },
            {
                "style": "Text",
                "text": "<i>The formula:</i>"
            },
            {
                "style": "Text",
                "text": "<code class=\"language-none\">annualized rate of return = (((investment + profits) / investments) ^ (365 / days)) - 1</code>"
            },
            {
                "style": "Text",
                "text": "In the context of the episode base asset and episode quoted asset, the calculation is done relative to the corresponding assets, and the overall context."
            },
            {
                "style": "Text",
                "text": "<i>The formulas:</i>"
            },
            {
                "style": "Text",
                "text": "<code class=\"language-none\">"
            },
            {
                "style": "Text",
                "text": "tradingEngine.current.episode.episodeBaseAsset.annualizedRateOfReturn.value ="
            },
            {
                "style": "Text",
                "text": "((( tradingEngine.current.episode.episodeBaseAsset.beginBalance.value +"
            },
            {
                "style": "Text",
                "text": "tradingEngine.current.episode.episodeBaseAsset.profitLoss.value ) /"
            },
            {
                "style": "Text",
                "text": "tradingEngine.current.episode.episodeBaseAsset.beginBalance.value) ^"
            },
            {
                "style": "Text",
                "text": "(365 / tradingEngine.current.episode.episodeStatistics.days.value)) - 1"
            },
            {
                "style": "Text",
                "text": "tradingEngine.current.episode.episodeQuotedAsset.annualizedRateOfReturn.value ="
            },
            {
                "style": "Text",
                "text": "((( tradingEngine.current.episode.episodeQuotedAsset.beginBalance.value +"
            },
            {
                "style": "Text",
                "text": "tradingEngine.current.episode.episodeQuotedAsset.profitLoss.value ) /"
            },
            {
                "style": "Text",
                "text": "tradingEngine.current.episode.episodeQuotedAsset.beginBalance.value) ^"
            },
            {
                "style": "Text",
                "text": "(365 / tradingEngine.current.episode.episodeStatistics.days.value)) - 1"
            },
            {
                "style": "Text",
                "text": "</code>"
            },
            {
                "style": "Text",
                "text": "<i>The JavaScript code:</i>"
            },
            {
                "style": "Text",
                "text": "<code class=\"language-js\">"
            },
            {
                "style": "Text",
                "text": "tradingEngine.current.episode.episodeBaseAsset.annualizedRateOfReturn.value ="
            },
            {
                "style": "Text",
                "text": "Math.pow("
            },
            {
                "style": "Text",
                "text": "             ( tradingEngine.current.episode.episodeBaseAsset.beginBalance.value +"
            },
            {
                "style": "Text",
                "text": "             tradingEngine.current.episode.episodeBaseAsset.profitLoss.value ) /"
            },
            {
                "style": "Text",
                "text": "             tradingEngine.current.episode.episodeBaseAsset.beginBalance.value"
            },
            {
                "style": "Text",
                "text": "             ,"
            },
            {
                "style": "Text",
                "text": "             (365 / tradingEngine.current.episode.episodeStatistics.days.value)"
            },
            {
                "style": "Text",
                "text": "        ) - 1"
            },
            {
                "style": "Text",
                "text": "tradingEngine.current.episode.episodeQuotedAsset.annualizedRateOfReturn.value ="
            },
            {
                "style": "Text",
                "text": "Math.pow("
            },
            {
                "style": "Text",
                "text": "             ( tradingEngine.current.episode.episodeQuotedAsset.beginBalance.value +"
            },
            {
                "style": "Text",
                "text": "             tradingEngine.current.episode.episodeQuotedAsset.profitLoss.value ) /"
            },
            {
                "style": "Text",
                "text": "             tradingEngine.current.episode.episodeQuotedAsset.beginBalance.value"
            },
            {
                "style": "Text",
                "text": "             ,"
            },
            {
                "style": "Text",
                "text": "             (365 / tradingEngine.current.episode.episodeStatistics.days.value)"
            },
            {
                "style": "Text",
                "text": "        ) - 1"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "In the context of the episode statistics, the calculation is done using the consolidated balance, as explained in the profit loss definition."
            },
            {
                "style": "Note",
                "text": "When the context does not refer to either of the assets in particular, then both asset balances are consolidated, and denominated in the quoted asset."
            },
            {
                "style": "Text",
                "text": "<i>The JavaScript code:</i>"
            },
            {
                "style": "Text",
                "text": "<code class=\"language-js\">"
            },
            {
                "style": "Text",
                "text": "tradingEngine.current.episode.episodeStatistics.annualizedRateOfReturn.value ="
            },
            {
                "style": "Text",
                "text": "Math.pow("
            },
            {
                "style": "Text",
                "text": "            ("
            },
            {
                "style": "Text",
                "text": "                tradingEngine.current.episode.episodeBaseAsset.beginBalance.value *"
            },
            {
                "style": "Text",
                "text": "                tradingEngine.current.episode.beginRate.value +"
            },
            {
                "style": "Text",
                "text": "                tradingEngine.current.episode.episodeQuotedAsset.beginBalance.value +"
            },
            {
                "style": "Text",
                "text": "                tradingEngine.current.episode.episodeBaseAsset.profitLoss.value +"
            },
            {
                "style": "Text",
                "text": "                tradingEngine.current.episode.episodeQuotedAsset.profitLoss.value"
            },
            {
                "style": "Text",
                "text": "            ) /"
            },
            {
                "style": "Text",
                "text": "            ("
            },
            {
                "style": "Text",
                "text": "                tradingEngine.current.episode.episodeBaseAsset.beginBalance.value *"
            },
            {
                "style": "Text",
                "text": "                tradingEngine.current.episode.beginRate.value +"
            },
            {
                "style": "Text",
                "text": "                tradingEngine.current.episode.episodeQuotedAsset.beginBalance.value"
            },
            {
                "style": "Text",
                "text": "            )"
            },
            {
                "style": "Text",
                "text": "        ,"
            },
            {
                "style": "Text",
                "text": "            ("
            },
            {
                "style": "Text",
                "text": "                365 / tradingEngine.current.episode.episodeStatistics.days.value"
            },
            {
                "style": "Text",
                "text": "            )"
            },
            {
                "style": "Text",
                "text": "        ) - 1"
            },
            {
                "style": "Text",
                "text": "</code\">"
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the annualized rate of return node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Hit Fail",
        "definition": "Hit fail states whether a transaction is successful or not, hit meaning it is successful and fail meaning it is not.",
        "content": [
            {
                "style": "Text",
                "text": "Superalgos marks positions and even entire episodes as hits or fails, by evaluating profit loss for the corresponding context. If profit loss is positive, then the position or episode is a hit. If profit loss is negative, it is a fail."
            },
            {
                "style": "Note",
                "text": "Please refer to the definition of <i>hits</i> for the details."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the hit fail node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Current",
        "definition": "The current object refers to the context in which instances of several other objects exist&mdash;like episode, strategy, position, strategy stages, and so on&mdash;in particular, the instances that are open at the time of evaluation, hence the adjective current.",
        "content": [
            {
                "style": "Text",
                "text": "Conceptually, current is used as an adjective applied to different concepts, such as the current episode, the current strategy, the current position, or the current strategy stage, to indicate the instance that is passing at the moment."
            },
            {
                "style": "Text",
                "text": "The generation of offspring nodes under the current section of the hierarchy keeps track of information within the scope of the embodied concept: episode, strategy, position, and so on."
            },
            {
                "style": "Text",
                "text": "In other words, the episode, strategy and position nodes within the current section of the hierarchy feature information relative to the instances of the episode, strategy, and position that are currently passing, at any point in time."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the current node, select <i>Add Missing Items</i> on the trading engine node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Balance",
        "definition": "Balance is the running balance, that is, the amount of the asset that exists at any point in time.",
        "content": [
            {
                "style": "Text",
                "text": "The balance of an asset changes every time an order involving the asset is filled. When the trading bot consults the exchange to find out the status of each order placed, the exchange answers with the size filled and actual rate for the order. That is the information used to calculate balances."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the balance node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Begin Balance",
        "definition": "Begin balance is the balance at the datetime of the begin property of the parent node or concept.",
        "content": [
            {
                "style": "Text",
                "text": "In the context of an episode, it is the balance at the datetime the episode started."
            },
            {
                "style": "Text",
                "text": "In the context of a position, it is the balance at the datetime the position started."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the begin balance node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "End Balance",
        "definition": "End balance is the balance at the datetime of the end property of the parent node or concept.",
        "content": [
            {
                "style": "Text",
                "text": "In the context of an episode, it is the balance at the datetime the episode ended."
            },
            {
                "style": "Text",
                "text": "In the context of a position, it is the balance at the datetime the position was closed."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the end balance node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Distance To Event",
        "definition": "Distance to event features counters indicating how many periods (candles) have passed since the last occurrence of certain events, in the context of the episode.",
        "content": [
            {
                "style": "Text",
                "text": "The information may be used from within strategies, for example, to leave a cool-down period in-between positions, to separate orders in specific intervals, or to achieve any particular logic that may require counting how much time has passed since the last time a specific event was triggered."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the distance to event node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Trigger On",
        "definition": "Counts the periods since the last time a strategy was triggered on.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the trigger on node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Trigger Off",
        "definition": "Counts the periods since the last time a strategy was triggered off.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the trigger off node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Take Position",
        "definition": "Counts the periods since the last time a position was taken.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the take position node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Close Position",
        "definition": "Counts the periods since the last time a position was closed.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the close position node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Next Phase",
        "definition": "Counts the periods since the last time a next phase event was triggered.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the next phase node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Move To Phase",
        "definition": "Counts the periods since the last time a move to phase event was triggered.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the move to phase node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Create Order",
        "definition": "Counts the periods since the last time an order was created.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the create order node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Cancel Order",
        "definition": "Counts the periods since the last time an order was canceled.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the cancel order node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Close Order",
        "definition": "Counts the periods since the last time an order was closed.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the close order node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Strategy Trigger Stage",
        "definition": "Strategy trigger stage is the section of the data structure that keeps track of information specific to the scope of the trigger stage during the period the stage is open.",
        "content": [
            {
                "style": "Text",
                "text": "The trigger stage is active from the instant the trigger-on event is triggered until either the trigger-off event or the take position event gets triggered. Therefore, this section of the data structure features information spaning those periods only."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the strategy trigger stage node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Strategy Manage Stage",
        "definition": "Strategy manage stage is the section of the data structure that keeps track of information specific to the scope of the manage stage during the period the stage is open.",
        "content": [
            {
                "style": "Text",
                "text": "The manage stage is active from the instant the take position event is triggered until the instant either the stop or take profit targets are hit."
            },
            {
                "style": "Text",
                "text": "Therefore, this section of the data structure features information spaning those periods only."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the strategy manage stage node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Strategy Open Stage",
        "definition": "Strategy open stage is the section of the data structure that keeps track of information specific to the scope of the open stage during the period the stage is open.",
        "content": [
            {
                "style": "Text",
                "text": "The open stage is open from the instant the take position event gets triggered, and starts closing from the instant one of the following things happen:"
            },
            {
                "style": "Text",
                "text": "<ul><li>the target size is filled,</li>"
            },
            {
                "style": "Text",
                "text": "<li>the close stage event is triggered,</li>"
            },
            {
                "style": "Text",
                "text": "<li>the take profit or stop loss targets are hit.</li>"
            },
            {
                "style": "Text",
                "text": "</ul>"
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the strategy open stage node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Strategy Close Stage",
        "definition": "Strategy close stage is the section of the data structure that keeps track of information specific to the scope of the close stage during the period the stage is open.",
        "content": [
            {
                "style": "Text",
                "text": "The close stage is active from the instant either the stop loss or take profit targets are hit until the instant the target size is filled or the close stage event is triggered."
            },
            {
                "style": "Text",
                "text": "Therefore, this section of the data structure features information spaning those periods only."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the strategy close stage node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Strategy",
        "definition": "The strategy section of the trading engine keeps track of information relating to the trading strategies that are triggered-on, during the time they remain open.",
        "content": [
            {
                "style": "Text",
                "text": "The strategy node is available both in the current context and the last context, that is, you may retrieve information of the strategy that was last triggered or the one currently open."
            },
            {
                "style": "Text",
                "text": "A strategy is open from the instant it is triggered-on until the instant it is triggered-off. Therefore, this section of the data structure features information spaning those periods only."
            },
            {
                "style": "Text",
                "text": "This section provides all the basic details about the strategy, which is particularly useful when the trading system features multiple strategies. It also provides information about the context, that is, what is going on with the market at the time strategies are triggered-on and off."
            },
            {
                "style": "Text",
                "text": "Most interestingly, the strategy section provides information such as which situation was responsible for triggering the strategy. This may be particularly useful in complex strategies in which the trigger on event may be defined by multiple situations."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the strategy node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Strategy Name",
        "definition": "Strategy name features the name of the strategy that is currently open.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the strategy name node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Index",
        "definition": "Index is the position of the parent object in the corresponding data collection, as determined by the context.",
        "content": [
            {
                "style": "Text",
                "text": "In the context of a candle, <i>index</i> is the position of the current candle in the array of candles within the larger context, for example, an episode."
            },
            {
                "style": "Text",
                "text": "Trading systems may feature more than one strategy. In the context of a strategy, <i>index</i> is the position of the strategy within the trading system."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the index node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Status",
        "definition": "Status refers to the state of the object represented by the parent node at the moment of evaluation.",
        "content": [
            {
                "style": "Text",
                "text": "There are three possible status:"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">Not Open</code>: the object is not open at the current candle.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">Open</code>: the object is open at the current candle.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">Closed</code>: the object closes at the current candle.</li></ul>"
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the status node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Situation Name",
        "definition": "Situation name features the name of the situation that triggered a certain event, which is dependent on the context.",
        "content": [
            {
                "style": "Text",
                "text": "In the context of a strategy, it is the name of the situation that triggered-on the strategy."
            },
            {
                "style": "Text",
                "text": "In the context of a position, it's the name of the situation that triggered the take position event."
            },
            {
                "style": "Text",
                "text": "In the context of an order, it's the situation that triggered the create order event."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the situation name node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Algorithm Name",
        "definition": "Algorithm name is the name of the execution algorithm that opened the order, as specified in the trading system.",
        "content": [
            {
                "style": "Text",
                "text": "Assigning names to execution algorithms in the definition of the trading system makes tracking the execution of orders easier."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the algorithm name node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Order Name",
        "definition": "Order name is the name of the order as specified in the trading system.",
        "content": [
            {
                "style": "Text",
                "text": "Assigning names to orders in the definition of the trading system makes tracking the execution of orders easier."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the order name node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Serial Number",
        "definition": "Serial number is a sequential number assigned to the object represented by the parent node at the moment it is opened.",
        "content": [
            {
                "style": "Text",
                "text": "Serial numbers start at 1 and increment by 1 with each intance of the object that is opened."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the serial number node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Identifier",
        "definition": "Identifier is a unique alphanumeric string by which the object represented by the parent node may be unequivocally identified.",
        "content": [
            {
                "style": "Text",
                "text": "The property is what would be used to access a specific known record."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the identifier node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Exchange Id",
        "definition": "Exchange ID is a unique identifier the exchange assigns to the order, so that it may be unequivocally identified.",
        "content": [
            {
                "style": "Text",
                "text": "By default, it is the rate at the close of the last candle at the moment the order is placed. All market orders have the default rate value."
            },
            {
                "style": "Text",
                "text": "In the case of limit orders, it is the rate as specified by the formula under the order rate node. If no such definition exists, then limit orders use the default value as well."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the exchange id node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Lock",
        "definition": "Lock is an internal mechanism that blocks the data structure of the order at the trading engine when the definition of the order at the trading system disallows spawning multiple orders.",
        "content": [
            {
                "style": "Text",
                "text": "Possible values for lock are <code class=\"language-none\">open</code> and <code class=\"language-none\">closed</code>."
            },
            {
                "style": "Text",
                "text": "The moment an order is closed, the system checks the <code class=\"language-none\">spawnMultipleOrders</code> parameter at the order's configuration in the trading system. If the value is <code class=\"language-none\">false<code class=\"language-none\">, the system sets the lock to </code>closed</code> so that the data structure may not be used again during the same position."
            },
            {
                "style": "Text",
                "text": "At the moment of opening an order, the system checks the <code class=\"language-none\">spawnMultipleOrders</code> parameter at the order's configuration in the trading system. If the value is <code class=\"language-none\">false<code class=\"language-none\">, the system checks the value of the lock. If the value is </code>open</code>, then it may create the order; if it is <code class=\"language-none\">closed</code> then the order may not be created."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the lock node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Begin",
        "definition": "Begin is the datetime at the moment the object represented by the parent node began to exist.",
        "content": [
            {
                "style": "Text",
                "text": "In the context of a candle, it is the datetime of the open of the candle as provided by the exchange."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the begin node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "End",
        "definition": "End is the datetime on which the object represented by the parent node ceased to exist. In case the object has not been closed yet, it is the datetime at the moment of evaluation.",
        "content": [
            {
                "style": "Text",
                "text": "In the context of a candle, it is the datetime of the close of the candle as provided by the exchange."
            },
            {
                "style": "Text",
                "text": "In every other context, the datetime is given by the datetime of the moment of evaluation. When evaluating a point in time in which the object remains open, <i>end</i> stores the datetime of that moment, because the object existed until that point in time when the value was last being updated. Once the object is closed, the end value is not modified again."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the end node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Last Begin"
    },
    {
        "type": "Last End"
    },
    {
        "type": "Open",
        "definition": "Open is the rate at the datetime of the begin property, as provided by the exchange. That is, the rate at the open of the candle.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the open node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Close",
        "definition": "Close is the rate at the datetime of the end property, as provided by the exchange. That is, the rate at the close of the candle.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the close node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Min",
        "definition": "Min is the minimum rate registered by the exchange during the period between the datetimes of the begin and end properties, as provided by the exchange.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the min node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Max",
        "definition": "Max is the maximum rate registered by the exchange during the period between the datetimes of the begin and end properties, as provided by the exchange.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the max node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Begin Rate",
        "definition": "Begin rate is the close rate of the candle corresponding to the datetime of the begin property.",
        "content": [
            {
                "style": "Text",
                "text": "In the context of a strategy, it is the close rate of the last closed candle at the moment the strategy was triggered."
            },
            {
                "style": "Text",
                "text": "In the context of a position, it is the close rate of the last closed candle at the moment the take position event was triggered."
            },
            {
                "style": "Text",
                "text": "In the context of an episode, it is the close rate of the last closed candle at the moment the episode starts."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the begin rate node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "End Rate",
        "definition": "End rate is the close rate of the candle corresponding to the datetime of the end property.",
        "content": [
            {
                "style": "Text",
                "text": "In the context of a strategy, it is the close rate of the last closed candle at the moment the strategy is triggered-off."
            },
            {
                "style": "Text",
                "text": "In the context of a position, it is the close rate of the last closed candle at the moment the close stage is closed."
            },
            {
                "style": "Text",
                "text": "In the context of an episode, it is the close rate of the last closed candle at the moment the episode ends."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the end rate node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Position",
        "definition": "Position is the section of the data structure that keeps track of information within the scope of each position, and during the time a position is open.",
        "content": [
            {
                "style": "Text",
                "text": "The position node is available both in the current context and the last context, that is, you may retrieve information of the position that was last opened or the one currently open."
            },
            {
                "style": "Text",
                "text": "A position is open from the instant the take position event is triggered until the instant the close stage is closed. Therefore, this section of the data structure features information spaning those periods only."
            },
            {
                "style": "Text",
                "text": "In this section of the hierarchy, you have access to:"
            },
            {
                "style": "Text",
                "text": "<ul><li> <b>balances and position performance metrics</b> denominated in both the base and quoted assets;</li>"
            },
            {
                "style": "Text",
                "text": "<li><b>counters</b>, such as the number of periods the position has been open;</li>"
            },
            {
                "style": "Text",
                "text": "<li><b>statistics</b>, such as performance metrics consolidating both assets, or user-defined statistics;</li>"
            },
            {
                "style": "Text",
                "text": "<li><b>the distance to certain events</b>, such as the number of candles to the last  take position event, or the last create order event;</li>"
            },
            {
                "style": "Text",
                "text": "<li><b>rates describing each candle</b> in the episode, such as the open, close, min and max rates;</li></ul>"
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the position node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Rate",
        "definition": "Rate is the rate at which the order is placed.",
        "content": [
            {
                "style": "Text",
                "text": "By default, it is the rate at the close of the last candle at the moment the order is placed. All market orders have the default rate value."
            },
            {
                "style": "Text",
                "text": "In the case of limit orders, it is the rate as specified by the formula under the order rate node. If no such definition exists, then limit orders use the default value as well."
            },
            {
                "style": "Text",
                "text": "The rate is used by the system for all internal calculations affecting the accounts kept in both assets."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the rate node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Entry Target Rate",
        "definition": "Entry target rate is the target rate set on the initial targets definition, in the open stage of the strategy.",
        "content": [
            {
                "style": "Text",
                "text": "Refresh this concepts by reading about the initial target definitions at the trading system."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the entry target rate node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Exit Target Rate",
        "definition": "Exit target rate is the target rate set on the initial targets definition, in the close stage of the strategy.",
        "content": [
            {
                "style": "Text",
                "text": "Refresh this concepts by reading about the initial target definitions at the trading system."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the exit target rate node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Stage Defined In"
    },
    {
        "type": "Size",
        "definition": "Size is the size set for the order through a combination of formulas and configurations defined in the trading system, and is the value passed on to the exchange as the size of the order.",
        "content": [
            {
                "style": "Text",
                "text": "The system provides a flexible and robust infrastructure to control execution. The size of a single order results from the combination of multiple settings."
            },
            {
                "style": "Text",
                "text": "<ul><li><b>The target size in base asset or target size in quoted asset</b>: The formulas under these nodes define the absolute maximum size allowed for the position. The implications of using one or the other are explained under the initial targets node in the open stage.</li>"
            },
            {
                "style": "Text",
                "text": "<li><b>The configuration of the execution algorithm</b>: The parameter <code class=\"language-none\">percentageOfStageTargetSize</code> determines what fraction of the target size the algorithm will attempt to execute.</li>"
            },
            {
                "style": "Text",
                "text": "<li><b>The configuration of the order</b>: The parameter <code class=\"language-none\">percentageOfAlgorithmSize</code> determines what fraction of the size handled by the algorithm the order shall be constrained to.</li></ul>"
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the size node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Actual Size"
    },
    {
        "type": "Amount Received"
    },
    {
        "type": "Fees To Be Paid"
    },
    {
        "type": "Entry Target Size",
        "definition": "Entry target size is the target size set on the initial targets definition, in the open stage of the strategy.",
        "content": [
            {
                "style": "Text",
                "text": "Refer to the explanations on the entry target size for some relevant context."
            },
            {
                "style": "Text",
                "text": "Refresh this concepts by reading about the initial target definitions at the trading system."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the entry target size node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Exit Target Size",
        "definition": "Exit target size is the target size set on the initial targets definition, in the close stage of the strategy.",
        "content": [
            {
                "style": "Text",
                "text": "Both entry and exit target sizes may be defined either denominated in the base asset or the quoted asset. Nevertheless, the sytem keeps track of target sizes in both assets. If the target is defined denominated in the base asset, then the target for the quoted asset is calculated using the current rate, and viceversa."
            },
            {
                "style": "Text",
                "text": "Refresh this concepts by reading about the initial target definitions at the trading system."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the exit target size node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Size Placed",
        "definition": "Size placed is the size of the order placed at the exchange.",
        "content": [
            {
                "style": "Text",
                "text": "In the context of a strategy stage, the size placed refers to the sum of the sizes placed for all orders placed on the corresponding stage."
            },
            {
                "style": "Text",
                "text": "In the context of an order, it refers to the size placed for the particular order."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the size placed node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Target Size",
        "definition": "Target size is the target set on the initial targets definition which, in the context of a strategy stage, acts as a limit.",
        "content": [
            {
                "style": "Text",
                "text": "Both the close and open stages may have multiple execution algorithms, each with multiple orders defined. In this context, the target size acts as a limit, as it is defined by the user as the maximum size allowed for any given position."
            },
            {
                "style": "Text",
                "text": "Before placing an order, the system makes sure that the size limit embodied in the target size would not be breached by opening a new order."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the target size node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Exit Type",
        "definition": "Exit type refers to the reason why the object is closed.",
        "content": [
            {
                "style": "Text",
                "text": "<code class=\"language-none\">No Exit</code> is the default value until a new value is assigned before the object is closed. Other possible values vary with the context."
            },
            {
                "style": "Text",
                "text": "In the context of the episode object:"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">Last Candle Reached</code>: the object was closed because the last candle was reached.</li>"
            },
            {
                "style": "Text",
                "text": "</ul>"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">Position Closed</code>: the position was closed.</li>"
            },
            {
                "style": "Text",
                "text": "</ul>"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">Take Profit</code>: the take profit target was hit.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">Stop Loss</code>: the stop loss target was hit.</li>"
            },
            {
                "style": "Text",
                "text": "</ul>"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">Closing Stage</code>: the current stage started closing because the Close Stage is opening.</li></ul>"
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the exit type node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Process Date"
    },
    {
        "type": "Head Of The Market"
    },
    {
        "type": "Last",
        "definition": "The last object stores instances of position and strategy objects, in particular the instances that were last open at the time of evaluation, hence the adjective last.",
        "content": [
            {
                "style": "Text",
                "text": "Conceptually, last is used as an adjective applied to these concepts, such as the last position or the last strategy, providing the context on which those concepts exist."
            },
            {
                "style": "Text",
                "text": "The <i>last</i> context exists so that you may easily access information about the strategy that was last triggered or the position that was last opened."
            },
            {
                "style": "Text",
                "text": "This is valuable information, both for users and trading systems alike."
            },
            {
                "style": "Text",
                "text": "<ul><li>As a user, you will value being able to visually follow what happened with the last position after it closed, or the last strategy after it triggered off, and at the same time see what is going on with the current position or the current strategy.</li>"
            },
            {
                "style": "Text",
                "text": "<li>From within a trading system, your strategies may make decisions factoring in what happened with the last position or strategy. For example, you may want to affect the size of the next position depending on the result of the last one.</li>"
            },
            {
                "style": "Text",
                "text": "</ul>"
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the last node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Candle",
        "definition": "The candle structure of nodes stores the properties that make up each candle in the episode, including open and close datetime, and the rates for open, min, max, and close.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the candle node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Cycle",
        "definition": "The trading bot performs its duties in regards to exchange orders and accounts in two consecutive cycles for each candle.",
        "content": [
            {
                "style": "Text",
                "text": "In the first cycle, it checks the status of orders at the exchange, synchronizes the accounts, and verifies if conditions to place new orders are met."
            },
            {
                "style": "Text",
                "text": "In the second cycle, it creates the orders at the exchange, provided conditions where met on the previous cycle."
            },
            {
                "style": "Text",
                "text": "The two possible values for the cycle node are <code class=\"language-none\">First</code> and <code class=\"language-none\">Second</code>."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the cycle node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "</code\">"
            }
        ],
        "starting": []
    },
    {
        "type": "Exchange Orders",
        "definition": "Exchange orders is the section of the data structure that keeps track of orders of all types.",
        "content": [
            {
                "style": "Text",
                "text": "The function of this section of the trading engine is to provide the data structure to hold the information of orders as they are open and closed."
            },
            {
                "style": "Text",
                "text": "Orders are organized by type, such as market orders and limit orders, and also by the type of transaction, such as buy or sell orders."
            },
            {
                "style": "Text",
                "text": "Each section of the hierarchy must have the definition of as many orders of each type as the trading system is capable of placing concurrently. For example, if the execution algorithm may place up to three limit buy orders to open a position, then three limit orders must exist under the limit buy orders section of the hierarchy. Each order defined in the trading system must reference the data structure of a matching type of order in the trading engine."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the exchange orders node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Market Buy Orders",
        "definition": "Market buy orders is the section of the data structure that keeps track of this specific type of order.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the market buy orders node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Market Order",
        "definition": "Market order is the section of the data structure that keeps track of the properties of a specific market order, as defined in the trading system.",
        "content": [
            {
                "style": "Text",
                "text": "Each market order defined in the trading system must reference the data structure of a market order in the trading engine."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the market order node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Market Sell Orders",
        "definition": "Market sell orders is the section of the data structure that keeps track of this specific type of order.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the market sell orders node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Limit Buy Orders",
        "definition": "Limit buy orders is the section of the data structure that keeps track of this specific type of order.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the limit buy orders node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Limit Sell Orders",
        "definition": "Limit sell orders is the section of the data structure that keeps track of this specific type of order.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the limit sell orders node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Limit Order",
        "definition": "Limit order is the section of the data structure that keeps track of the properties of a specific limit order, as defined in the trading system.",
        "content": [
            {
                "style": "Text",
                "text": "Each limit order defined in the trading system must reference the data structure of a limit order in the trading engine."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the limit order node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Trading Parameters",
        "definition": "Parameters are properties of trading sessions, defined by users, to determine their behavior and improve the quality of simulations.",
        "content": [
            {
                "style": "Text",
                "text": "The behavior of parameters may vary depending on the type of session."
            },
            {
                "style": "Text",
                "text": "Each testing session has its own set of parameters. This allows you to configure different trading sessions with different parameters, and go back and forth between them as required. For instance, you may have different backtesting sessions with different date ranges, different exchange fees or different slippage settings to account for different possible scenarios."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a parameters node, select <i>Add Parameters</i> on the session or the trading system menu, depending on the context. When a parameters node is added, the full set of parameters are created with it."
            },
            {
                "style": "Text",
                "text": "If you already have a parameters node but are missing some of the parameters, then select <i>Add Missing Params</i> on the menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Learning Parameters"
    },
    {
        "type": "Trading System Reference",
        "definition": "A trading engine reference determines which trading system shall be evaluated by the trading bot to run the trading session.",
        "content": [
            {
                "style": "Text",
                "text": "In other words, the trading system reference lets the process instance know which trading rules to process for the given session."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a trading ensystemgine reference, select <i>Add Missing Children</i> on the trading session node menu."
            },
            {
                "style": "Note",
                "text": "After adding a trading system reference node, make sure you establish the reference to the corresponding trading system hierarchy."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Trading Engine Reference",
        "definition": "A trading engine reference determines which trading engine the trading bot shall use to structure the data it processes while running the trading session.",
        "content": [
            {
                "style": "Text",
                "text": "In other words, the trading engine reference lets the process instance know which data structure to use to store information related to the trading session. This means that a workspace may have more than one trading engine."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a trading engine reference, select <i>Add Missing Children</i> on the trading session node menu."
            },
            {
                "style": "Note",
                "text": "After adding a trading engine reference node, make sure you establish the reference to the corresponding trading engine hierarchy."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Session Base Asset",
        "definition": "The base asset is the asset whose price is determined by the market. It is usually the first asset in the pair, as listed by the exchange.",
        "content": [
            {
                "style": "Text",
                "text": "Among other things, the parameter allows defining an initial balance of the corresponding asset, which may be used for trading with the corresponding trading system and trading session. Please see the configuration."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a parameter that may be missing, select <i>Add Missing Params</i> on the parameters node menu."
            },
            {
                "style": "Note",
                "text": "After adding a base asset node, make sure you establish a reference to the asset in a specific market of a specific exchange in the Crypto Ecosystem hierarchy."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure Base Asset</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "\"initialBalance\": 0.001,"
            },
            {
                "style": "Text",
                "text": "\"minimumBalance\": 0.0001,"
            },
            {
                "style": "Text",
                "text": "\"maximumBalance\": 0.1"
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">initialBalance</code> is the amount of capital you wish to allocate to the trading system.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">minimumBalance</code> is the threshold of accummulated losses that switches off the session; when your overall balance (balanceAssetA + balanceAssetB) drops to this value, all trading stops; think of the <code class=\"language-none\">minimumBalance</code> as a general safety switch.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">maximumBalance</code> is a similar concept as with the <code class=\"language-none\">minimumBalance<code class=\"language-none\"> but on the high side of the </code>initialBalance</code>.</li></ul>"
            }
        ]
    },
    {
        "type": "Session Quoted Asset",
        "definition": "The quoted asset is the asset on which the price of the base asset is denominated in the market. It is usually the second asset in the pair, as listed by the exchange.",
        "content": [
            {
                "style": "Text",
                "text": "The parameter allows defining an initial balance of the corresponding asset, which may be used for trading with the corresponding trading system and trading session. Please see the configuration."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a parameter that may be missing, select <i>Add Missing Params</i> on the parameters node menu."
            },
            {
                "style": "Note",
                "text": "After adding a quoted asset node, make sure you establish a reference to the second asset in the same market of the same exchange as the reference established with the base asset."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Market Base Asset",
        "definition": "The market base asset is the asset in the pair used to provide a quote&mdash;a price&mdash;for the quoted asset, as listed at the exchange.",
        "content": [
            {
                "style": "Text",
                "text": "A market base asset must reference an asset defined under the exchange assets node."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a market base asset, select <i>Add Market Base Asset</i> on the market node menu."
            },
            {
                "style": "Note",
                "text": "Remember to establish a reference with an asset defined under the exchange assets node."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Market Quoted Asset",
        "definition": "The market quoted asset is the asset in the pair for which a quote is given, denominated in the base asset, as listed at the exchange.",
        "content": [
            {
                "style": "Text",
                "text": "A market quoted asset must reference an asset defined under the exchange assets node."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a market quoted asset, select <i>Add Market Quoted Asset</i> on the market node menu."
            },
            {
                "style": "Note",
                "text": "Remember to establish a reference with an asset defined under the exchange assets node."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Time Range",
        "definition": "The time range parameter determines the period of time on which the trading session is run.",
        "content": [
            {
                "style": "Text",
                "text": "The parameter offers precise control over the duration, starting and ending points of the session. Several options are available, and there are differences in how backtesting and the rest of the types of trading sessions function in this regard."
            },
            {
                "style": "Text",
                "text": "Check the configuration to learn more."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a parameter that may be missing, select <i>Add Missing Params</i> on the parameters node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure Time Range</i> on the menu to access the configuration. The configuration varies slightly depending on the type of session you are running."
            },
            {
                "style": "Text",
                "text": "<H4>On Backtesting Sessions</H4>"
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "\"initialDatetime\": \"2019-09-01T00:00:00.000Z\","
            },
            {
                "style": "Text",
                "text": "\"finalDatetime\": \"2019-09-25T00:00:00.000Z\""
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">initialDatetime</code> is the datetime the session starts at.</li>"
            },
            {
                "style": "Text",
                "text": "</ul>"
            },
            {
                "style": "Text",
                "text": "<H4>On Paper Trading, Forward Testing and Live Trading Sessions</H4>"
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "\"initialDatetime\": \"2019-09-01T00:00:00.000Z\","
            },
            {
                "style": "Text",
                "text": "\"finalDatetime\": \"2019-09-25T00:00:00.000Z\","
            },
            {
                "style": "Text",
                "text": "\"allowStartingFromThePast\": false"
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<i> <code class=\"language-none\">finalDatetime</code> is the datetime the session finishes at. If you don't set a </i>finalDatetime* at the level of the testing session or the trading system, then the session runs for one year."
            },
            {
                "style": "Text",
                "text": "By default, paper trading, forward testing and live trading sessions start at the datetime the session is run, that is, the present time. Such a behavior is in accordance with the most common use case, by which a user starting a new live trading session usually wishes the session to start at that moment."
            },
            {
                "style": "Text",
                "text": "However, users have requested to be allowed to start live sessions in the past. Such a feature may be useful, for example, to take an opportunity that was just missed for whatever reason, including technical ones."
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">initialDatetime</code>, in combination with the <code class=\"language-none\">allowStartingFromThePast<code class=\"language-none\"> parameter, is a hack to allow a live session to start from a date in the past. If there is a valid </code>initialDatetime</code> and <code class=\"language-none\">allowStartingFromThePast</code> is <code class=\"language-none\">true<code class=\"language-none\">, then the live session effectively starts from the specified date in the past. If </code>allowStartingFromThePast</code> is <code class=\"language-none\">false</code> the <code class=\"language-none\">initialDatetime</code> is ignored and the session starts from the present time.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">allowStartingFromThePast</code> may be <code class=\"language-none\">true<code class=\"language-none\"> or </code>false</code>.</li>"
            },
            {
                "style": "Warning",
                "text": "</ul>"
            }
        ],
        "starting": []
    },
    {
        "type": "Time Frame",
        "definition": "The time frame determines the collection of candles to be analyzed during a backtesting session, and the frequency with which the trading bot runs on paper trading, forward testing, and live trading sessions.",
        "content": [
            {
                "style": "Text",
                "text": "In the context of backtesting sessions, what time frame you decide to run the session depends on the trading system being tested. If the trading system makes decisions based on the 1-hour candle and above, then <code class=\"language-none\">01-hs</code> may be the best choice. However, if decisions are influenced by sub-hour candles then you should match the time frame accordingly."
            },
            {
                "style": "Text",
                "text": "In other words, in backtesting sessions, you should match the time frame to the smallest period on which the trading system makes decisions."
            },
            {
                "style": "Text",
                "text": "In the context of live sessions, that is, paper trading, forward testing, and live trading, you should run the session on the <code class=\"language-none\">01-min</code> time frame so that the trading bot reacts fast when the price tags the take profit or stop loss targets. Remember that stop and take profit orders are not placed at the exchange after the take position event, that is, once you enter the position. Instead, the trading bot checks the current price upon each execution cycle and determines whether targets have been hit or not. If targets are hit, only then orders are placed. That is why running live trading sessions at the <code class=\"language-none\">01-min</code> time frame is recommended. Learn more about the management of take profit and stop loss targets."
            },
            {
                "style": "Text",
                "text": "If for whatever reason you don't need to minimize the potential for slippage when hitting stop or take profit targets, you may choose whatever time frame you like, taking into account the explanations below."
            },
            {
                "style": "Text",
                "text": "<H4>Why the Time Frame Matters</H4>"
            },
            {
                "style": "Success",
                "text": "Running trading sessions of any given trading system on different time frames may produce different results. This is because the behavior of a trading session may vary depending on how well the time frame on which the session is run matches the logic of the strategy."
            },
            {
                "style": "Text",
                "text": "This is why:"
            },
            {
                "style": "Text",
                "text": "The trading bot evaluates closed candles only. At any given point in time, the current candle in each time frame is the candle that closed last."
            },
            {
                "style": "Text",
                "text": "<i>For example:</i>"
            },
            {
                "style": "Text",
                "text": "Let's say it's <code class=\"language-none\">2020-06-11T11:39:30:00.000Z</code>, that is, 11 hours, 39 minutes and 30 seconds of June 11th, 2020."
            },
            {
                "style": "Text",
                "text": "<ul><li>The current 1-minute candle is the one which closed at 11:38:59.999.</li>"
            },
            {
                "style": "Text",
                "text": "<li>The current 5-minute candle is the one which closed at 11:34:59.999.</li>"
            },
            {
                "style": "Text",
                "text": "<li>The current 30-minute candle is the one which closed at 11:29:59.999.</li>"
            },
            {
                "style": "Text",
                "text": "<li>The current 1-hour candle is the one which closed at 10:59:59.999.</li>"
            },
            {
                "style": "Text",
                "text": "<li>The current 2-hour candle is the one which closed at 09:59:59.999.</li>"
            },
            {
                "style": "Text",
                "text": "<li>The current 6-hour candle is the one which closed at 05:59:59.999.</li>"
            },
            {
                "style": "Text",
                "text": "<li>The current 24-hour candle is the one which closed at 23:59:59.999 of June 10th!</li>"
            },
            {
                "style": "Text",
                "text": "</ul>"
            },
            {
                "style": "Text",
                "text": "Let's say the trading system implements conditions that evaluate 30-minute and 1-hour candles."
            },
            {
                "style": "Text",
                "text": "If a session is run at the 30-minutes time frame, all 30-minutes candles are evaluated. Also, all 1-hour candles are evaluated twice."
            },
            {
                "style": "Text",
                "text": "However, if the session is run at the 1-hour time frame, only one out of two 30-minute candles are evaluated."
            },
            {
                "style": "Text",
                "text": "And if the session is run at the 2-hour time frame, only one out of four 30-minute candles and one out of two 1-hour candles are evaluated."
            },
            {
                "style": "Text",
                "text": "This means that running the session (for this particular trading system) at the 30-minute time frame has higher probabilities of conditions evaluating 30-minute candles to be <code class=\"language-none\">true</code> during the session."
            },
            {
                "style": "Success",
                "text": "In other words, when running the session on time frames higher than the time frame on which decisions are made, chances are the bot will eventually skip candles on which conditions would have evaluated true, potentially skipping trading opportunities."
            },
            {
                "style": "Text",
                "text": "The above is true for all types of trading sessions."
            },
            {
                "style": "Text",
                "text": "<H4>Backtesting Vs. Live Sessions</H4>"
            },
            {
                "style": "Text",
                "text": "In a backtesting session, the collection of candles evaluated is determined by the time frame selected to better simulate what would happen if the live trading session was run in the same time frame."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a parameter that may be missing, select <i>Add Missing Params</i> on the parameters node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure Time Frame</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-js\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "\"value\": \"01-min\""
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">value</code> is the setting for the time frame. You may use any of the values below.</li>"
            },
            {
                "style": "Text",
                "text": "</ul>"
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "01-min"
            },
            {
                "style": "Text",
                "text": "02-min"
            },
            {
                "style": "Text",
                "text": "03-min"
            },
            {
                "style": "Text",
                "text": "04-min"
            },
            {
                "style": "Text",
                "text": "05-min"
            },
            {
                "style": "Text",
                "text": "10-min"
            },
            {
                "style": "Text",
                "text": "15-min"
            },
            {
                "style": "Text",
                "text": "20-min"
            },
            {
                "style": "Text",
                "text": "30-min"
            },
            {
                "style": "Text",
                "text": "45-min"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "Available options at larger time frames are:"
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "01-hs"
            },
            {
                "style": "Text",
                "text": "02-hs"
            },
            {
                "style": "Text",
                "text": "03-hs"
            },
            {
                "style": "Text",
                "text": "04-hs"
            },
            {
                "style": "Text",
                "text": "06-hs"
            },
            {
                "style": "Text",
                "text": "08-hs"
            },
            {
                "style": "Text",
                "text": "12-hs"
            },
            {
                "style": "Text",
                "text": "24-hs"
            },
            {
                "style": "Text",
                "text": "</code\">"
            }
        ],
        "starting": []
    },
    {
        "type": "Slippage",
        "definition": "The slippage is an assumption on the difference between the simulated rate and the actual fill rate of a market order, most relevant in the context of backtesting and paper-trading sessions. The parameter is a tool to make simulations more realistic.",
        "content": [
            {
                "style": "Text",
                "text": "In the context of forward testing and live trading sessions, slippage does not affect the actual transactions. However, the parameter is taken into account when creating the live trading simulation until the actual order fill values are obtained from the exchange."
            },
            {
                "style": "Note",
                "text": "Check the configuration section for the details on how slippage works."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a parameter that may be missing, select <i>Add Missing Params</i> on the parameters node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "\"positionRate\": 0.1,"
            },
            {
                "style": "Text",
                "text": "\"stopLoss\": 0.2,"
            },
            {
                "style": "Text",
                "text": "\"takeProfit\": 0.3"
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<i> <code class=\"language-none\">positionRate</code> is the slippage value applied to the rate of all market orders throughout the position, expressed as a percentage (</i>i.e.:* 0.1 means 0.1%)."
            },
            {
                "style": "Text",
                "text": "<i> <code class=\"language-none\">stopLoss</code> is the slippage value applied to the stop loss target defined by the formulas of each stop loss phase in the manage stage of the trading system, expressed as a percentage (</i>i.e.:<i> 0.2 means 0.2%). The slippage value is applied to the value resulting from the corresponding stop loss formula, and the actual stop loss target is the resulting number. For example, if the stop loss formula results in <code class=\"language-none\">1000<code class=\"language-none\"> and the </code>stopLoss</code> slippage value is <code class=\"language-none\">0.2</code>, then the resulting stop loss target is  <code class=\"language-none\">1000<code class=\"language-none\"> <b>&plusmn;</b> </code>1000 </i> 0.2 / 100</code>. Read below for an explanation on when the slippage is added or subtracted."
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">takeProfit</code> works similarly as the <code class=\"language-none\">stopLoss</code> setting, but affecting the take profit target instead of the stop loss target.</li>"
            },
            {
                "style": "Text",
                "text": "</ul>"
            },
            {
                "style": "Text",
                "text": "{% include note.html content=\"If the slippage parameter is left empty or detached both from your session and your trading system, slippage is not computed during simulations.\"%}"
            }
        ],
        "starting": []
    },
    {
        "type": "Fee Structure",
        "definition": "The fee structure is a parameter fundamental to the calculation of fees, both in testing and live trading sessions.",
        "content": [
            {
                "style": "Text",
                "text": "Exchange fees are a crucial part of trading. A strategy may work like a charm when you leave fees out of the equation but would lead you to bankruptcy in a live trading situation."
            },
            {
                "style": "Text",
                "text": "Exchanges don't usually report the amount charged in fees on each transaction, thus, the system calculates fees and subtract them from balances. Learn more about the handling of fees."
            },
            {
                "style": "Important",
                "text": "The accuracy of the internal account-keeping depends on this parameter. Make sure you obtain the correct fee structure from the exchange corresponding to the tier of your account."
            },
            {
                "style": "Text",
                "text": "To illustrate how fees affect your bottom line, take a look at the image below."
            },
            {
                "style": "Text",
                "text": "<img src=\"Projects/Superalgos/Docs-Gifs/trading-simulation-fees-fails.gif\"></img>"
            },
            {
                "style": "Text",
                "text": "The trade hits the take profit target above the Position Rate level, however, due to fees, the trade has a negative 0.32% ROI."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a parameter that may be missing, select <i>Add Missing Params</i> on the parameters node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure Fee Structure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "\"maker\": 0.15,"
            },
            {
                "style": "Text",
                "text": "\"taker\": 0.25"
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">maker</code> is the setting for the fee the exchange charges when an order adds liquidity to the market, such as with limit orders.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">taker</code> is the setting for the fee the exchange charges when an order takes liquidity from the market, such as with market or instant orders.</li>"
            },
            {
                "style": "Note",
                "text": "</ul>"
            },
            {
                "style": "Note",
                "text": "If the fee structure parameter is left empty or detached both from your session and your trading system, fees are not computed during simulations."
            },
            {
                "style": "Important",
                "text": "Remember that, for the time being, and until the new execution engine is released, all orders placed by the trading bot are <i>market orders</i>, thus, the <i>taker</i> fee applies in all cases."
            }
        ],
        "starting": []
    },
    {
        "type": "Snapshots",
        "definition": "Snapshots are CSV files output by the trading bot listing every trade in a backtesting session. The snapshots parameter determines whether snapshots shall be produced, and how.",
        "content": [
            {
                "style": "Text",
                "text": "Learn more about snapshots and check the configuration file to control if and how snapshots are produced."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a parameter that may be missing, select <i>Add Missing Params</i> on the parameters node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure Slippage</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "   \"strategy\": true,"
            },
            {
                "style": "Text",
                "text": "   \"position\": true"
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">strategy</code> determines whether to take a snapshot at the trigger on event or not; possible values are <code class=\"language-none\">true<code class=\"language-none\"> or </code>false</code>.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">position</code> determines whether to take a snapshot at the take position event or not; possible values are <code class=\"language-none\">true<code class=\"language-none\"> or </code>false</code>.</li></ul>"
            }
        ],
        "starting": []
    },
    {
        "type": "Heartbeats",
        "definition": "During a trading session, the backend communicates with the frontend via heartbeats to inform the frontend about the status of the session. The parameter controls what information is made available to the user through the frontend.",
        "content": [
            {
                "style": "Text",
                "text": "This parameter affects how you see the progress of the trading session below the trading bot instance node on the design space."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a parameter that may be missing, select <i>Add Missing Params</i> on the parameters node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure Slippage</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "   \"date\": true,"
            },
            {
                "style": "Text",
                "text": "   \"candleIndex\": false"
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">date</code> determines whether the date is shown in the progress notice below the trading process instance node; possible values are <code class=\"language-none\">true<code class=\"language-none\"> or </code>false</code>.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">candleIndex</code> determines whether the index of the candle is shown in the progress notice below the trading process instance node; possible values are <code class=\"language-none\">true<code class=\"language-none\"> or </code>false</code>.</li></ul>"
            }
        ],
        "starting": []
    },
    {
        "type": "Learning Algorithm"
    },
    {
        "type": "User Defined Parameters",
        "definition": "Users may define parameters to be used within the trading system during the trading session.",
        "content": [
            {
                "style": "Text",
                "text": "Parameters defined in the configuration file of these node become available to trading systems using the following path: <code class=\"language-none\">sessionParameters.userDefinedParameters.config.parameterName</code>."
            },
            {
                "style": "Text",
                "text": "These parameters may be useful, for example, when you wish to use a <i>constant</i> multiple times across several nodes in the definition of a strategy. Instead of feeding a constant value to all formulas involved, you may feed the parameter instead. This gives you the added benefit of being able to change the value of such a constant in a single point."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a parameter that may be missing, select <i>Add Missing Params</i> on the parameters node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure Slippage</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "   \"param1Name\": \"A text string value example\","
            },
            {
                "style": "Text",
                "text": "   \"param2Name\": 0"
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">param1Name</code> is an example of a name. You may change the names of the parameters as required. Values including text strings go between quotation marks, while numeric values, without. You may define as many parameters as you wish; simply separate them with a comma to keep a valid JSON format for the configuration file.</li></ul>"
            }
        ],
        "starting": []
    },
    {
        "type": "Time Frames Filter",
        "definition": "The time frame filters node allows control over which time frames are to be calculated by each indicator bot instance running on the data mining operation.",
        "content": [
            {
                "style": "Text",
                "text": "Limiting the number of time frames calculated by any given indicator to the few that may be required by a particular trading system has a significant positive impact on performance: it reduces the load on the CPU, the memory requirements, and the requirements of storage space, in proportion with the time frames you remove."
            },
            {
                "style": "Text",
                "text": "When a time frames filter is set up, a <code class=\"language-none\">Time.Frames.json</code> file is created by the indicator process in the corresponding output folder. This file is read by others&mdash;such as the charting system&mdash;to get the information regarding which time frames are available and which are not, to avoid reporting errors."
            },
            {
                "style": "Important",
                "text": "Before applying a time frames filter or changing the configuration, that is, changing which time frames are produced and which are not, it is highly recommended to delete the data corresponding to the affected indicator, to avoid inconsistencies in the data that may later cause confusion."
            },
            {
                "style": "Note",
                "text": "When no time frames filter is defined, the bot processes all time frames by default."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the time frames filter node, select <i>Add Time Frames Filter</i> on the parent node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "\"dailyTimeFrames\": [ \"45-min\", \"40-min\", \"30-min\", \"20-min\", \"15-min\", \"10-min\", \"05-min\", \"04-min\", \"03-min\", \"02-min\", \"01-min\" ],"
            },
            {
                "style": "Text",
                "text": "\"marketTimeFrames\": [ \"24-hs\", \"12-hs\", \"08-hs\", \"06-hs\", \"04-hs\", \"03-hs\", \"02-hs\", \"01-hs\"]"
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<i> <code class=\"language-none\">dailyTimeFrames</code> features the time frames corresponding to the </i>daily files* type of data structure; in practical terms, the time frames below one hour."
            },
            {
                "style": "Text",
                "text": "<i> <code class=\"language-none\">marketTimeFrames</code> features the time frames corresponding to the </i>market files* type of data structure; in practical terms, the time frames of one hour and above."
            },
            {
                "style": "Text",
                "text": "{% include tip.html content=\"Remove the time frames you are not interested in, making sure the JSON file is still valid.\" %}"
            }
        ],
        "starting": []
    },
    {
        "type": "Paper Trading Session",
        "definition": "A paper trading session is a trading mode by which the trading bot instance reads a live market data feed, applies the rules defined in the associated trading system, and generates a trading simulation.",
        "content": [
            {
                "style": "Text",
                "text": "A paper trading session node must reference a trading system to gain access to the trading logic to be applied during the session. Other considerations framing the session come from the set of parameters attached to it."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a paper trading session, select <i>Add Paper Trading Session</i> on the trading process instance node menu. When a session is added, it is created with the full set of parameters."
            },
            {
                "style": "Note",
                "text": "After adding a session node, make sure you establish a reference to the trading system you want it to work with."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure Session</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "\"folderName\": \"Session-Name\""
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">folderName</code> allows you to set a significant name to the folder in which the data products&mdash;and logs&mdash;generated by the session are stored. If left blank, the system names the folders with the session id. This may be handy when you intend to consult the raw data generated by the session, as, otherwise, the folder would be hard to identify.</li></ul>"
            }
        ],
        "starting": [
            {
                "style": "Text",
                "text": "Before you start a paper trading session, the corresponding task needs to be running, as it is the task that puts the trading bot instance to run. Once the trading bot instance is running, select <i>Run</i> on the menu to start the session."
            },
            {
                "style": "Text",
                "text": "To stop a backtesting session, select <i>Stop</i> on the menu."
            }
        ]
    },
    {
        "type": "Forward Testing Session",
        "definition": "A forward testing session is a trading mode by which the trading bot instance performs live trading with a user-defined fraction of the available capital.",
        "content": [
            {
                "style": "Text",
                "text": "A forward testing session node must reference a trading system to gain access to the trading logic to be applied during the session. Other considerations framing the session come from the set of parameters attached to it."
            },
            {
                "style": "Important",
                "text": "Running a live session requires the setup of a key reference at the market reference. It also requires a live data feed, meaning that the corresponding sensor bot, along with all indicators used by the referenced trading system, must be up and running. Finally, a live session also requires at least 48 hours of historic market data. Bear in mind that the trading system may require even more historic market data to properly analyze the market."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a forward testing session, select <i>Add Forward Testing Session</i> on the trading process instance node menu. When a session is added, it is created with the full set of parameters."
            },
            {
                "style": "Note",
                "text": "After adding a session node, make sure you establish a reference to the trading system you want it to work with."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure Session</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "\"folderName\": \"Session-Name\","
            },
            {
                "style": "Text",
                "text": "\"balancePercentage\": 1"
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">folderName</code> allows you to set a significant name to the folder in which the data products&mdash;and logs&mdash;generated by the session are stored. If left blank, the system names the folders with the session id. This may be handy when you intend to consult the raw data generated by the session, as, otherwise, the folder would be hard to identify.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">balancePercentage</code> is a number defining the percentage of the initialBalance specified in the base aset configuration that will be used for trading. For instance, <code class=\"language-none\">\"balancePercentage\": 1<code class=\"language-none\"> means that 1% of your balance will be made available. Just like the </code>initialBalance</code> is scaled down, the <code class=\"language-none\">minimumBalance</code> and <code class=\"language-none\">maximumBalance</code> are also scaled down accordingly (see base asset).</li>"
            },
            {
                "style": "Text",
                "text": "</ul>"
            },
            {
                "style": "Text",
                "text": "Your base asset is USDT and your initialBalance is USDT 10,000."
            },
            {
                "style": "Text",
                "text": "If you set up your forward-testing session with \"balancePercentage\": \"1\", then USDT 10,000 * 1% = USDT 100. This is the balance that will be available to your forward-testing session."
            },
            {
                "style": "Important",
                "text": "You need to take this into account at the time of defining your positionSize formula. If the formula is a constant, you may easily run out of balance, as only a fraction of the balance will be available for the strategy to use. It may be a good idea to set up your positionSize as a function of your available balance instead."
            }
        ],
        "starting": [
            {
                "style": "Text",
                "text": "Before you start a forward testing session, the corresponding task needs to be running, as it is the task that puts the trading bot instance to run. Once the trading bot instance is running, select <i>Run</i> on the menu to start the session."
            },
            {
                "style": "Text",
                "text": "To stop a backtesting session, select <i>Stop</i> on the menu."
            }
        ]
    },
    {
        "type": "Key Reference",
        "definition": "The key reference is a reference to an exchange account key as defined in a specific user account, in a specific exchange, on the Crypto Ecosystem hierarchy.",
        "content": [
            {
                "style": "Text",
                "text": "Usually, exchanges require autentication via your exchange account key for monetary transactions only. However, some exchanges may require autentication in other contexts as well, for instance, to retrieve information above a certain quota, or to retrieve raw trades data instead of OHLCV data."
            },
            {
                "style": "Text",
                "text": "For those reasons, exchange key references are available both in the context of data mining and trading operations, and are always attached to the corresponding task."
            },
            {
                "style": "Text",
                "text": "Forward testing and live trading sessions always require setting up key references, as that is the kind of scenario in which the user must validate with the exchange."
            },
            {
                "style": "Text",
                "text": "In all cases, the key reference node must reference a valid exchange account key from an account with the exchange, as defined in the Crypto Ecosystem hierarchy."
            },
            {
                "style": "Important",
                "text": "Most exchanges do not allow the same exchange account key to be used with multiple processes querying the exchange API. This means that if you are trading with multiple trading systems or multiple sessions on the same exchange, each session requires different exchange account keys."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a key reference, select <i>Add Key Reference</i> on the task node menu."
            },
            {
                "style": "Note",
                "text": "Remember to establish a reference with a valid exchange account key after creating the key reference."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Live Trading Session",
        "definition": "A live trading session is a trading mode by which the trading bot instance reads a live market data feed, applies the rules as defined in the associated trading system, places the corresponding orders at the associated exchange, and stores the defined data products.",
        "content": [
            {
                "style": "Text",
                "text": "A live trading session node must reference a trading system to gain access to the trading logic to be applied during the session. Other considerations framing the session come from the set of parameters attached to it."
            },
            {
                "style": "Important",
                "text": "Running a live session requires the setup of a key reference at the market reference. It also requires a live data feed, meaning that the corresponding sensor bot, along with all indicators used by the referenced trading system, must be up and running. Finally, a live session also requires at least 48 hours of historic market data. Bear in mind that the trading system may require even more historic market data to properly analyze the market."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a live trading session, select <i>Add Live Trading Session</i> on the trading process instance node menu. When a session is added, it is created with the full set of parameters."
            },
            {
                "style": "Note",
                "text": "After adding a session node, make sure you establish a reference to the trading system you want it to work with."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure Session</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "\"folderName\": \"Session-Name\""
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">folderName</code> allows you to set a significant name to the folder in which the data products&mdash;and logs&mdash;generated by the session are stored. If left blank, the system names the folders with the session id. This may be handy when you intend to consult the raw data generated by the session, as, otherwise, the folder would be hard to identify.</li></ul>"
            }
        ],
        "starting": [
            {
                "style": "Text",
                "text": "Before you start a live trading session, the corresponding task needs to be running, as it is the task that puts the trading bot instance to run. Once the trading bot instance is running, select <i>Run</i> on the menu to start the session."
            },
            {
                "style": "Text",
                "text": "To stop a backtesting session, select <i>Stop</i> on the menu."
            }
        ]
    },
    {
        "type": "Learning Session"
    },
    {
        "type": "Sensor Bot Instance",
        "definition": "A sensor bot instance is a reference to a sensor bot as defined in a data mine. The instance of the bot runs the defined processes and generates the defined data products.",
        "content": [
            {
                "style": "Text",
                "text": "{{site.data.concepts.sensor_bot}}"
            },
            {
                "style": "Text",
                "text": "The sensor bot instance holds no definitions as to what the bot does. Instead, its process instance references a process definition in the corresponding data mine. That is how the sensor bot instance obtains the information regarding what it needs to do once it is run."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a sensor bot instance, select <i>Add Sensor Bot Instance</i> on the task node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure Sensor Bot Instance</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "  {"
            },
            {
                "style": "Text",
                "text": "    \"startDate\": \"2020-01-01\""
            },
            {
                "style": "Text",
                "text": "  }"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<i> <code class=\"language-none\">startDate</code> is the </i>desired starting date* of the data product the sensor bot instance builds, in the <code class=\"language-none\">YYYY-MM-DD<code class=\"language-none\"> format. The sensor bot instance queries its data source for data starting on the configured </code>startDate</code>."
            },
            {
                "style": "Text",
                "text": "  <i> The actual date in which the dataset starts depends on external factors: A. The market may start at a later date. B. The exchange may limit how far in the past data may be retrieved. In both cases, the sensor bot automatically discovers the date closest to the </i>desired starting date* that is possible to start with, and proceeds accordingly."
            },
            {
                "style": "Text",
                "text": "  * In the case the <code class=\"language-none\">startDate</code> is changed after the sensor bot has started building a data product, either for an earlier or later date, the sensor re-evaluates the feasibility of starting at the new date. The actual date may or may not change; regardless, the sensor bot discards the existing data product and starts over from the newly discovered date. In other words, if the <code class=\"language-none\">startDate</code> is changed, the sensor bot starts over."
            },
            {
                "style": "Text",
                "text": ""
            },
            {
                "style": "Text",
                "text": "  * Notice that the above starts a chain reaction among all indicator bots that have a data dependency with the sensor bot's output dataset. Also, if the actual date ends up changing, all indicators that determine the starting date of the market by looking at the date discovered by the sensor bot have to discard their existing data products and start over from the new date."
            }
        ],
        "starting": [
            {
                "style": "Text",
                "text": "You do not start or stop a sensor bot instance directly. Instead, you start or stop the corresponding task."
            }
        ]
    },
    {
        "type": "Indicator Bot Instance",
        "definition": "An indicator bot instance is a reference to an indicator bot as defined in a data mine. The instance of the bot runs the defined processes and generates the defined data products.",
        "content": [
            {
                "style": "Text",
                "text": "{{site.data.concepts.indicator_bot}}"
            },
            {
                "style": "Text",
                "text": "The indicator bot instance holds no definitions as to what the bot does. Instead, its processes instances reference the process definitions in the corresponding data mine. That is how the indicator bot instance obtains the information of what it needs to do once it is run."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add an indicator bot instance, select <i>Add Indicator Bot Instance</i> on the task node menu."
            }
        ],
        "configuring": [],
        "starting": [
            {
                "style": "Text",
                "text": "You do not start or stop an indicator bot instance directly. Instead, you start or stop the corresponding task."
            }
        ]
    },
    {
        "type": "Data Mine",
        "definition": "A data mine is a hierarchy that contains definitions of sensor and indicators bots, and their plotters. These definitions make up the actual programs of such bots&mdash;the source code.",
        "content": [
            {
                "style": "Text",
                "text": "In a way, data mines are catalogs of bots that anyone may create. This hierarchy provides all the tools required to create sensors, indicators, and plotters, with minimal coding required."
            },
            {
                "style": "Text",
                "text": "Because the hierarchy provides definitions, it does not intervene in the execution of bots. Instead, the definitions in data mines are instantiated from the network hierarchy by bot instances. Bot instances and process instances are the ones running the code according to the definitions in the corresponding data mine."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a data mine, select <i>Add Data Mine</i> on the mines node menu in the Superalgos Project hierarchy."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure Data Mine</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "\"codeName\": \"Supermine\""
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">codeName</code> is the name of the data mine as used within the code of the system.</li></ul>"
            }
        ],
        "starting": []
    },
    {
        "type": "Trading Mine",
        "definition": "A trading mine is a hierarchy that contains definitions of trading bots and their plotters. These definitions make up the actual programs of such bots&mdash;the source code.",
        "content": [
            {
                "style": "Text",
                "text": "Altough Superalgos is starting out with a single trading bot, the system is prepared to feature as many trading bots as developers are willing to create. As such, a trading mine is a catalog of trading bots."
            },
            {
                "style": "Text",
                "text": "Notice that, in the context of Superalgos, a trading bot has nothing to do with the trading logic. Think of trading logic as the business rules which&mdash;in Superalgos&mdash;are defined in trading systems. Anyone may build trading systems, meaning that creating a trading system and the trading strategies within does not require coding."
            },
            {
                "style": "Text",
                "text": "Trading mines work similarly to data mines in the sense that they provide the same kind of tools to structure the definitions of bots, including process definitions, product definitions, and plotters."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the trading mine node, select <i>Add Trading Mine</i> on the other hierarchies node menu in the Superalgos Project hierarchy."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "</code\">"
            }
        ],
        "starting": []
    },
    {
        "type": "Learning Mine"
    },
    {
        "type": "Sensor Bot",
        "definition": "A sensor bot is an algorithm that extracts raw data from external sources (i.e.: exchanges, Twitter, etc.) and stores it in a dataset that other bots may consume.",
        "content": [
            {
                "style": "Text",
                "text": "The sensor bot node holds all definitions required for a sensor bot to function. Definitions are split between the definition of processes and products. A sensor's processes is an algorithm that obtains data from a third pary and produces an output for other bots to consume. Part of that output is the data products the bot creates."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a sensor bot, select <i>Add Sensor Bot</i> on the data mine node menu. A sensor bot is created along with the basic structure of nodes required to define it."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure Bot</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "\"codeName\": \"Super\","
            },
            {
                "style": "Text",
                "text": "\"repo\": \"Super-Sensor-Bot\""
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">codeName</code> is the name of the bot as used within the code of the system.</li></ul>"
            }
        ],
        "starting": []
    },
    {
        "type": "Process Definition",
        "definition": "The process definition node groups all definitions required for a process to function. The Multi-Period-Market Process deals with time frames of one hour and above. The Multi-Period-Daily Process deals with time frames of 45 minutes and below.",
        "content": [
            {
                "style": "Text",
                "text": "As hinted above, most bots&mdash;in particular indicators&mdash;have two different processes. The reason is that different data structures need to be handled in different manners. The Multi-Period-Daily process handles <i>daily files</i>, while the Multi-Period-Market process handles <i>market files</i>."
            },
            {
                "style": "Text",
                "text": "The Multi-Period-Market process deals with time frames of one hour and above. Because these time frames produce relatively small numbers of records, the process builds one single file per time frame spanning the whole market history&mdash;hence the name Multi-Period-<i>Market</i>."
            },
            {
                "style": "Text",
                "text": "On the other hand, the Multi-Period-Daily process deals with time frames below one hour. These time frames produce huge numbers of records, therefore, the corresponding data must be fragmented in multiple files. The Multi-Period-Daily process builds one file per day for each time frame&mdash;hence the name Multi-Period-<i>Daily</i>."
            },
            {
                "style": "Note",
                "text": "The way in which datasets are structured by each of the processes is determined by the corresponding dataset definitions."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a process definition, select <i>Add Process Definition</i> on the bot's menu. A process definition node is created along with the basic structure of nodes comprising the definition."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure Process</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<b>Multi-Period-Market:</b>"
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "  {"
            },
            {
                "style": "Text",
                "text": "    \"codeName\": \"Multi-Period-Market\","
            },
            {
                "style": "Text",
                "text": "    \"normalWaitTime\": 0,"
            },
            {
                "style": "Text",
                "text": "    \"retryWaitTime\": 10000,"
            },
            {
                "style": "Text",
                "text": "    \"framework\": {"
            },
            {
                "style": "Text",
                "text": "      \"name\": \"Multi-Period-Market\""
            },
            {
                "style": "Text",
                "text": "    }"
            },
            {
                "style": "Text",
                "text": "  }"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<b>Multi-Period-Daily:</b>"
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "  {"
            },
            {
                "style": "Text",
                "text": "    \"codeName\": \"Multi-Period-Daily\","
            },
            {
                "style": "Text",
                "text": "    \"normalWaitTime\": 0,"
            },
            {
                "style": "Text",
                "text": "    \"retryWaitTime\": 10000,"
            },
            {
                "style": "Text",
                "text": "    \"framework\": {"
            },
            {
                "style": "Text",
                "text": "      \"name\": \"Multi-Period-Daily\""
            },
            {
                "style": "Text",
                "text": "    }"
            },
            {
                "style": "Text",
                "text": "  }"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">codeName</code> is the name of the process as used within the code of the system.</li></ul>"
            }
        ],
        "starting": []
    },
    {
        "type": "Process Output",
        "definition": "The process output groups the definitions of which datasets are impacted by the process, that is, which datasets the process builds or takes a part in building.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add a process output node, select <i>Add Missing Items</i> on the process definition node menu. Items that may be missing are created along with the basic structure of nodes required to define them."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Process Dependencies",
        "definition": "Process dependencies are references to various data structures on which the process depends to function.",
        "content": [
            {
                "style": "Text",
                "text": "While processes run autonomously, most processes participate in a value-adding chain by which a process produces a data product that other processes may consume as an input to be processed further. This means that bots&mdash;while autonomous in their particular jobs&mdash;do depend both on other bots and on the data other bots produce."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a process dependencies node, select <i>Add Missing Items</i> on the process definition node menu. Items that may be missing are created along with the basic structure of nodes required to define them."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Status Dependency",
        "definition": "Status dependencies are references to a status report that define which process the process establishing the reference depends on.",
        "content": [
            {
                "style": "Text",
                "text": "The reference is established to acquire the information relative to what the target process is doing. For example, by reading a status report a process may learn when was the last time the referenced process ran, and what was the last file processed."
            },
            {
                "style": "Text",
                "text": "The status report referenced may belong to the same process&mdash; which is called a self-reference. In such a case, the process is learning what it did the last time it ran. Also, the status report referenced may belong to another process&mdash;another bot. In that case, the dependency may be of the Market Starting Point or Market Ending Point types."
            },
            {
                "style": "Text",
                "text": "<ul><li><b>Self Reference</b> is mandatory, as a process needs to read its own status report every time it wakes up.</li>"
            },
            {
                "style": "Text",
                "text": "<li><b>Market Starting Point</b> is a status dependency existing on Multi-Period-Daily processes so that the process establishing the reference learns the datetime of the start of the market. Usually, the reference is established with the sensor's Historic-OHLCVs process status report. Multi-Period-Market processes do not have this type of status dependency as the date of the start of the market is implied in their dataset (a single file with all market data).</li>"
            },
            {
                "style": "Text",
                "text": "<li><b>Market Ending Point</b> is a status dependency existing both in Multi-Period-Market and Multi-Period-Daily processes so that the process establishing the reference knows the datetime of the end of the market.</li>"
            },
            {
                "style": "Text",
                "text": "</ul>"
            },
            {
                "style": "Text",
                "text": "The image above shows a case of a self-reference status dependency as well as a market ending point status dependency."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a status dependency, select <i>Add Status Dependency</i> on the process dependencies node menu."
            },
            {
                "style": "Text",
                "text": "{% include tip.html content=\"Remember that a status dependency must be configured, and must establish a reference to the appropriate status report.\" %}"
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure Status Dependency</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "\"mainUtility\": \"Self Reference|Market Starting Point|Market Ending Point\""
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">mainUtility</code> determines the type of status dependency, with possible values being <code class=\"language-none\">Self Reference<code class=\"language-none\">, </code>Market Starting Point</code>, or <code class=\"language-none\">Market Ending Point</code>.</li></ul>"
            }
        ],
        "starting": []
    },
    {
        "type": "Status Report",
        "definition": "Status reports serve as temporal annotations that bots read every time they run to know what was done in the previous cycle and what the state of affairs is at present. Status reports are dynamic, and they change constantly, with updates after every cycle of the associated process.",
        "content": [
            {
                "style": "Text",
                "text": "Bots do not run continuously. Instead, they run in cycles. A cycle usually lasts until there is no more data to process, and once they finish, they shut down until the next cycle is due. A status report is a file every bot writes at the end of each cycle with information about the last run, including the datetime of the run and the last record processed."
            },
            {
                "style": "Text",
                "text": "A status report may be consumed by the same bot producing it, or by other bots."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a status report, select <i>Add Missing Items</i> on the process definition node menu. Items that may be missing are created along with the basic structure of nodes required to define them."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Execution Started Event",
        "definition": "The execution started event is the event that triggers the execution of a process. It usually references the execution finished event of another process on which the process depends on.",
        "content": [
            {
                "style": "Text",
                "text": "These references determine when a process is due for another run. By listening to the execution finished event of the process it depends on, it may wake up just in time to process the new batch of data the dependency has just delivered."
            },
            {
                "style": "Text",
                "text": "Bots form a sort of multi-branched execution sequence with an indeterminate number of dependencies. Every time the bot further down the tree of dependencies finishes a cycle, it triggers the execution of multiple bots listening to its execution finished event."
            },
            {
                "style": "Text",
                "text": "In the context of a trading process instance running a trading session on the network hierarchy, the execution started event may be used to force the trading process to run only after the last indicator bot dependency finishes its job. This guarantees that all dependencies are up to date and that the trading bot will evaluate the information corresponding to the same candles for all indicators used by the trading system."
            },
            {
                "style": "Text",
                "text": "Not setting up this event on a trading session may result in eventual data inconsistencies, as&mdash;in theory&mdash;the trading bot may run with some indicators up to date and some slightly delayed."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add an execution started event, select <i>Add Missing Items</i> on the process definition node menu. Items that may be missing are created along with the basic structure of nodes required to define them."
            },
            {
                "style": "Text",
                "text": "{% include tip.html content=\"Remember that an execution started event must establish a reference to the appropriate execution finished event.\" %}"
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Execution Finished Event",
        "definition": "The execution finished event is the event that processes trigger once they have finished an execution cycle. The event is broadcasted to whoever wants to listen, so that other bots may know when the process has finished its execution cycle.",
        "content": [
            {
                "style": "Text",
                "text": "The execution finished event is responsible for triggering the execution of every process that depends on the data a bot produces. If bot Alice depends on bot Bob, Alice listens to the execution finished event of Bob so that it may start a new execution cycle as soon as Bob finishes its cycle. Alice listens to Bob's execution finished event by establishing a reference from its execution started event."
            },
            {
                "style": "Text",
                "text": "<img src=\"Projects/Superalgos/Docs-Gifs/indicators-process-execution-started-finished-events-01.gif\"></img>"
            },
            {
                "style": "Text",
                "text": "The image above shows a reference established from the execution started event of a process to the execution finished event of another process."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add an execution finished event, select <i>Add Missing Items</i> on the process definition node menu. Items that may be missing are created along with the basic structure of nodes required to define them."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Output Dataset Folder",
        "definition": "An output dataset folder is an organizational device used to create arrangements of output datasets, particularly useful when the bot has many products.",
        "content": [
            {
                "style": "Text",
                "text": "In cases in which a single bot has many different products, output dataset folders may help organize the outputs referencing each product, making their management easier. Folders may be nested like folders in the file system."
            },
            {
                "style": "Text",
                "text": "The use of output dataset folders is optional, as product definitions may also exist outside of folders."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the output dataset folder node, select <i>Add Output Dataset Folder</i> on the parent node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "</code\">"
            }
        ],
        "starting": []
    },
    {
        "type": "Product Definition Folder",
        "definition": "A product definition folder is an organizational device used to create arrangements of product definitions, particularly useful when the bot has many products.",
        "content": [
            {
                "style": "Text",
                "text": "In cases in which a single bot has many different products, product definitions folders may help organize those products, making their management easier. Folders may be nested like folders in the file system."
            },
            {
                "style": "Text",
                "text": "The use of product definition folders is optional, as product definitions may also exist outside of folders."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the product definition folder node, select <i>Add Product Definition Folder</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Product Definition",
        "definition": "The product definition node holds all definitions that make up a product, including how the product is calculated and the datasets the product is comprised of.",
        "content": [
            {
                "style": "Text",
                "text": "A bot may feature multiple products, thus, there may be multiple product definitions. Three main aspects need to be defined in terms of products: the characteristics of the dataset, the composition of each record, and the way records are calculated."
            },
            {
                "style": "Note",
                "text": "A product definition usually references a plotter module, which provides a graphic representation of the underlying dataset"
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a product definition, select <i>Add Product Definition</i> on the bot's node menu. A product definition is created along with the basic structure of nodes required to make up a product."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure Product</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "  \"codeName\": \"Product-Name\","
            },
            {
                "style": "Text",
                "text": "  \"singularVariableName\": \"productName\","
            },
            {
                "style": "Text",
                "text": "  \"pluralVariableName\": \"productNames\""
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">codeName</code> is the name of the product as it is used within the bot's code.</li>"
            },
            {
                "style": "Text",
                "text": "</ul>"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">pluralVariableName</code> is the plural form of the variable.</li></ul>"
            }
        ],
        "starting": []
    },
    {
        "type": "Dataset Definition",
        "definition": "A data set is a collection of files stored in the designated location, as per the definitions on the referenced data product in the corresponding data mine.",
        "content": [
            {
                "style": "Text",
                "text": "A good part of what makes datasets easy to consume by other bots is the fact that they are standardized in terms of their structure. It is that structure that is specified in the dataset definitions."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a dataset definition, select <i>Add Dataset Definition</i> on the bot's node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure Definition</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<b>Multi-Period-Market:</b>"
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "    \"codeName\": \"Multi-Period-Market\","
            },
            {
                "style": "Text",
                "text": "    \"type\": \"Market Files\","
            },
            {
                "style": "Text",
                "text": "    \"validTimeFrames\": [ \"24-hs\", \"12-hs\", \"08-hs\", \"06-hs\", \"04-hs\", \"03-hs\", \"02-hs\", \"01-hs\" ],"
            },
            {
                "style": "Text",
                "text": "    \"filePath\": \"@Exchange/@BaseAsset-@QuotedAsset/@DataMine/@Bot/Output/@Product/@Dataset/@Period\","
            },
            {
                "style": "Text",
                "text": "    \"fileName\": \"Data.json\","
            },
            {
                "style": "Text",
                "text": "    \"timeFrames\": {"
            },
            {
                "style": "Text",
                "text": "      \"filePath\": \"\","
            },
            {
                "style": "Text",
                "text": "      \"fileName\": \"\""
            },
            {
                "style": "Text",
                "text": "    }"
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<b>Multi-Period-Daily:</b>"
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "    \"codeName\": \"Multi-Period-Daily\","
            },
            {
                "style": "Text",
                "text": "    \"type\": \"Daily Files\","
            },
            {
                "style": "Text",
                "text": "    \"validTimeFrames\": [ \"45-min\", \"40-min\", \"30-min\", \"20-min\", \"15-min\", \"10-min\", \"05-min\", \"04-min\", \"03-min\", \"02-min\", \"01-min\" ],"
            },
            {
                "style": "Text",
                "text": "    \"filePath\": \"@Exchange/@BaseAsset-@QuotedAsset/@DataMine/@Bot/Output/@Product/@Dataset/@Period/@Year/@Month/@Day\","
            },
            {
                "style": "Text",
                "text": "    \"fileName\": \"Data.json\","
            },
            {
                "style": "Text",
                "text": "    \"dataRange\": {"
            },
            {
                "style": "Text",
                "text": "      \"filePath\": \"@Exchange/@BaseAsset-@QuotedAsset/@DataMine/@Bot/Output/@Product/@Dataset\","
            },
            {
                "style": "Text",
                "text": "      \"fileName\": \"Data.Range.json\""
            },
            {
                "style": "Text",
                "text": "    },"
            },
            {
                "style": "Text",
                "text": "    \"timeFrames\": {"
            },
            {
                "style": "Text",
                "text": "      \"filePath\": \"\","
            },
            {
                "style": "Text",
                "text": "      \"fileName\": \"\""
            },
            {
                "style": "Text",
                "text": "    }"
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">codeName</code> is the name of the dataset as used within the code.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">type</code> refers to the type of dataset; possible values are <code class=\"language-none\">Market Files<code class=\"language-none\"> and </code>Daily Files</code>.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">validTimeFrames</code> refers to the time frames handled by the dataset.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">filePath</code> sets the path on which files are stored; the proper name of the data mine, the bot and the product need to be entered.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">fileName</code> sets the name of the files that constitute the dataset.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">timeFrames</code> sets the name and path of the file indicating which time frames shall be filtered when the users sets a time frames filter.</li></ul>"
            }
        ],
        "starting": []
    },
    {
        "type": "Indicator Bot",
        "definition": "An indicator bot is an algorithm that processes information that other bots have generated, and produces elaborate datasets for others to consume.",
        "content": [
            {
                "style": "Text",
                "text": "The indicator bot node holds all definitions required for an indicator bot to function. Definitions are split between the definition of processes and products. Processes are algorithms that go through an input dataset, perform certain calculations, and produce an output. Products are the outcome of the work produced by these algorithms, in the form of ellaborate data sets."
            },
            {
                "style": "Text",
                "text": "Most of the behavior expected from an indicator bot is defined by the structure of nodes in the hierarchy and the references among the nodes within these definitions. As such, you do not need to code any of the functions that make up the infrastructure functionality. Dependencies, outputs, data structures, execution sequences, and several other problems are handled by the definitions embodied in the structure of nodes that make up an indicator, and are configured in the visual environment of the design space. Coding is limited to the actual calculation and data building procedures."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add an indicator bot, select <i>Add Indicator Bot</i> on the data mine node menu. An indicator bot is created along with the basic structure of nodes required to define it."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure Bot</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "\"codeName\": \"Superbot\""
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">codeName</code> is the name of the bot as used within the code of the system.</li></ul>"
            }
        ],
        "starting": []
    },
    {
        "type": "Output Dataset",
        "definition": "The output dataset is a reference to a dataset definition. By establishing such reference, the process acquires the definitions as of how the dataset is to be constructed.",
        "content": [
            {
                "style": "Text",
                "text": "There are other effects of establishing a reference from the output dataset to a product dataset definition. Upon execution, every time a process finishes a processing cycle, it triggers an event that may be consumed by other entities. This event indicates that the datasets impacted by the process have been updated."
            },
            {
                "style": "Text",
                "text": "An example of other entities that may be listening to such events is that of plotters. Plotters read datasets and create graphical representations of this data over the charts. Charts are constantly updating the information in the form of candles and indicators in realtime, synchronized with the data being extracted from the exchange by the sensor bot. That kind of automatism is possible thanks to the events that processes trigger every time an execution cycle is finished, signaling to everyone listening that new data is available on each of the impacted datasets."
            },
            {
                "style": "Text",
                "text": "<img src=\"Projects/Superalgos/Docs-Gifs/indicators-process-output-01.gif\"></img>"
            },
            {
                "style": "Text",
                "text": "The image above shows the typical references from output datasets to datasets definitions."
            },
            {
                "style": "Note",
                "text": "An output dataset must reference a dataset definition."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "Output datasets may be added in bulk, for all defined products, or one by one."
            },
            {
                "style": "Text",
                "text": "To add a single output dataset node, select <i>Add Output Dataset</i> on the process output menu."
            },
            {
                "style": "Text",
                "text": "{% include tip.html content=\"Remember that an output dataset must reference a valid dataset definition. Make sure you establish the reference after creating the output dataset.\" %}"
            },
            {
                "style": "Text",
                "text": "If you have defined multiple products, each with their dataset definitions, and wish to create all corresponding output datasets in bulk, select *Add All Output Datasets\" on the process output menu. The system maps the product definition folder structure with output dataset folders, creates all required output datasets, and establishes the references with the corresponding dataset definitions, with a single click of the button."
            },
            {
                "style": "Note",
                "text": "Make sure each product has properly defined dataset definitions before creating output datasets in bulk. You may always delete the output datasets and re-create them at will."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Data Dependency",
        "definition": "Data dependencies are references established with dataset definitions of other bots, determining which datasets the process establishing the reference uses as input.",
        "content": [
            {
                "style": "Text",
                "text": "Most bots consume data other bots have produced. Because bots need the data as input for their calculations, processes establish a data dependency with the dataset definitions of other bots. The reference provides the process with all the information needed to decode the dataset, enabling it to perform the required calculations."
            },
            {
                "style": "Text",
                "text": "<img src=\"Projects/Superalgos/Docs-Gifs/indicators-process-dependencies-02.gif\"></img>"
            },
            {
                "style": "Text",
                "text": "The image above shows data dependencies in one bot referencing dataset definitions of another bot."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a single data dependency, select <i>Add Data Dependency</i> on the process dependencies, bot data dependencies, or data dependency folder node menus."
            },
            {
                "style": "Text",
                "text": "{% include tip.html content=\"Remember that a data dependency must establish a reference to the appropriate dataset definition. When adding data dependencies manually, you also need to manually establish the reference.\" %}"
            },
            {
                "style": "Text",
                "text": "In cases in which multiple data dependencies must be established, you may use the option to create data dependencies in bulk:"
            },
            {
                "style": "Text",
                "text": "<i> The </i>Add All Data Dependencies* option on the data mine data dependencies node menu adds a bot data dependency for each bot in the data mine, and a data dependency for each dataset definition or each product of each bot. You may use this option after manually adding a data mine data dependencies node and manually establishing the reference with the desired data mine, or after adding all data mine data dependencies, by which the references with data mines are established automatically."
            },
            {
                "style": "Text",
                "text": "It is unlikely that a bot requires numerous data dependencies, thus, the most common scenario is setting up individual data dependencies and establishing references manually. However, if your bot requires multiple data dependencies, the bulk features may be quite useful, as you may create all data dependencies for any given data mine, and simply delete those that are not required."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Record Definition",
        "definition": "The record definition is where indicators define how many properties, what properties and in which order those properties will be made available in each record.",
        "content": [
            {
                "style": "Text",
                "text": "Bots store data in the form of arrays of records, in a minimized plain text file and the standard JSON format, although not as objects with named properties, but as arrays."
            },
            {
                "style": "Text",
                "text": "{% include image-ext.html file='https://user-images.githubusercontent.com/13994516/68998023-303eae00-08ad-11ea-9baa-ddea801c7d6d.png' url='yes' max-width='100' caption='Typical dataset file showing records as arrays.' %}"
            },
            {
                "style": "Text",
                "text": "The choice of plain text for storage of large volumes of information has benefits in terms of not requiring any sophisticated technology to store and serve the data (<i>i.e.:</i> no database is required)."
            },
            {
                "style": "Text",
                "text": "Best practice indicates that there needs to be a balance between the amount of data that is stored and calculations that may be performed at runtime."
            },
            {
                "style": "Text",
                "text": "Storing objects with named properties in the JSON format would be inappropriate as labels would repeat over and over, creating a ridiculous amount of unnecessary information. However, storing arrays in the JSON standard facilitates the handling of files in the context of JavaScript and Node.JS."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a record definition node, select <i>Add Record Definition</i> on the product definition node menu. A record definition node is created along with the first record property."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Record Property",
        "definition": "A record property is a piece of information that may be stored as part of the dataset or made available as a calculated property.",
        "content": [
            {
                "style": "Text",
                "text": "Records may have as many properties as required."
            },
            {
                "style": "Important",
                "text": "The order in which record properties are defined around the parent record definition node is the order in which they are stored in the actual record."
            },
            {
                "style": "Text",
                "text": "{% include tip.html content=\"The first two records are usually the <i>begin</i> and <i>end</i> records, featuring the corresponding datetimes that indicate when the record starts and ends.\" %}"
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a record property, select <i>Add Record Property</i> on the bot's node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure Property</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-js\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "  \"codeName\": \"record-name\","
            },
            {
                "style": "Text",
                "text": "  \"isString\": false,"
            },
            {
                "style": "Text",
                "text": "  \"isCalculated\": true"
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">codeName</code> is the name of the record as it is used in the bot's code.</li>"
            },
            {
                "style": "Text",
                "text": "</ul>"
            },
            {
                "style": "Text",
                "text": "<i> <code class=\"language-none\">isCalculated</code> determines if the field is stored in the dataset or if, instead, is calculated at a later stage. A value </i>true* means that the record is not stored. In the case <code class=\"language-none\">isCaculated</code> is not defined in the configuration, it is assumed to be false."
            },
            {
                "style": "Text",
                "text": "<img src=\"Projects/Superalgos/Docs-Gifs/indicators-record-definitions-01.gif\"></img>"
            },
            {
                "style": "Text",
                "text": "The image above shows a record definition with four record properties."
            }
        ],
        "starting": []
    },
    {
        "type": "Formula",
        "definition": "A formula is a mathematical expression intended to determine a numerical value to be applied dynamically to a certain property.",
        "content": [
            {
                "style": "Text",
                "text": "In the context of a trading system, formulas are used to determine the values for several properties, such as the target rate, target size, managed stop loss, managed take profit, and so on."
            },
            {
                "style": "Text",
                "text": "Formulas may use indicators and trading engine properties. The main difference between writing a formula and writing a condition is that while conditions must evaluate to <code class=\"language-none\">true</code> or <code class=\"language-none\">false</code>, formulas must evaluate to a number."
            },
            {
                "style": "Text",
                "text": "<b>A simple math example:</b>"
            },
            {
                "style": "Text",
                "text": "This simple formula may be used to define an initial take profit target 3% above the rate at which the position was taken."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-none\">"
            },
            {
                "style": "Text",
                "text": "tradingEngine.current.position.entryTargetRate.value * 1.03"
            },
            {
                "style": "Text",
                "text": "</code>"
            },
            {
                "style": "Note",
                "text": "You may use any variable made available by the trading engine, as explained on the accessing runtime data page."
            },
            {
                "style": "Text",
                "text": "<b>A simple JavaScript example:</b>"
            },
            {
                "style": "Text",
                "text": "A bit of very basic JavaScript, introducing conditional statements, allows more intelligence. For example, in this case, we ask if the proposed formula results in a number greater than the current stop loss value; if it does, then the proposed formula is used; if not, then the current stop loss value is left as is."
            },
            {
                "style": "Text",
                "text": "This is&mdash;basically&mdash;a trailing stop loss 2% below the moving average that may go higher if the moving average goes up, but it may never come down&mdash;thanks to the use of the IF ELSE clause."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-js\">"
            },
            {
                "style": "Text",
                "text": "if (chart.at01hs.bollingerBand.movingAverage * 0.98 > tradingEngine.current.position.stopLoss.value)"
            },
            {
                "style": "Text",
                "text": "   {chart.at01hs.bollingerBand.movingAverage * 0.98}"
            },
            {
                "style": "Text",
                "text": "   else"
            },
            {
                "style": "Text",
                "text": "   {tradingEngine.current.position.stopLoss.value}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<b>For developers:</b>"
            },
            {
                "style": "Text",
                "text": "To build more complex logic within a formula, create a function that implements the logic and returns a numerical value, and then call the function:"
            },
            {
                "style": "Text",
                "text": "<code class=\"language-js\">"
            },
            {
                "style": "Text",
                "text": "function orderRate() {"
            },
            {
                "style": "Text",
                "text": "    const ORDER_STEP_NUMBER = 1    // Secuential step number, starting with 1 from the closest to the price."
            },
            {
                "style": "Text",
                "text": "    const BUY_SELL_SIGN = -1       // 1 for buy orders, -1 for sell orders."
            },
            {
                "style": "Text",
                "text": "    const STEP_SEPARATION = 0.15   // % of separation of stair steps between them."
            },
            {
                "style": "Text",
                "text": "    const BASE_FACTOR = 0.2        // % above or below bollinger band without bias."
            },
            {
                "style": "Text",
                "text": "    const BIAS_FACTOR = 0.3        // % to move the whole stair of orders up or down depending on the bias."
            },
            {
                "style": "Text",
                "text": "    const BAND_RATE = chart.at01min.bollingerBand.lowerBand    //  Upper Bollinger Band for sell orders, and Lower for buy orders."
            },
            {
                "style": "Text",
                "text": "    let inbalance = tradingEngine.current.episode.episodeBaseAsset.beginBalance.value - tradingEngine.current.episode.episodeBaseAsset.balance.value"
            },
            {
                "style": "Text",
                "text": "    let BIAS_SIGN"
            },
            {
                "style": "Text",
                "text": "    if (inbalance === 0) {"
            },
            {
                "style": "Text",
                "text": "        BIAS_SIGN = 0"
            },
            {
                "style": "Text",
                "text": "    }"
            },
            {
                "style": "Text",
                "text": "    if (inbalance < 0) {"
            },
            {
                "style": "Text",
                "text": "        BIAS_SIGN = + 1"
            },
            {
                "style": "Text",
                "text": "    }"
            },
            {
                "style": "Text",
                "text": "    if (inbalance > 0) {"
            },
            {
                "style": "Text",
                "text": "        BIAS_SIGN = - 1"
            },
            {
                "style": "Text",
                "text": "    }"
            },
            {
                "style": "Text",
                "text": "    let rate = BAND_RATE + BUY_SELL_SIGN <i> BAND_RATE </i> (BASE_FACTOR + ORDER_STEP_NUMBER <i> STEP_SEPARATION + BIAS_SIGN </i> BIAS_FACTOR) / 100"
            },
            {
                "style": "Text",
                "text": "    return rate"
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "orderRate()"
            },
            {
                "style": "Text",
                "text": "</code\">"
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a formula, select <i>Add Formula</i> on the corresponding parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Announcement Formula"
    },
    {
        "type": "Calculations Procedure",
        "definition": "The calculations procedure processes information to be fed to calculated properties. Calculated properties are not stored in the data set; instead, they are calculated in real-time as the data is consumed by others.",
        "content": [
            {
                "style": "Text",
                "text": "Bots store data in the minimized array format as a strategy to build the lightest possible datasets. For the same reason, a bot may choose not to store easily calculable information."
            },
            {
                "style": "Text",
                "text": "For example, imagine an indicator that stores buy and sell volumes... does it <i>need</i> to store the total volume? Given that it is so easy to calculate, the answer is <i>probably</i> not. It is up to the developer to decide, but it is certainly not required."
            },
            {
                "style": "Note",
                "text": "The calculations procedure is used to calculate properties that the developer chooses not to store in the dataset."
            },
            {
                "style": "Note",
                "text": "To fully understand the role of the calculations procedure, please refer to the data mining workflow page."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a calculations procedure, select <i>Add Missing Items</i> on the product definition node menu. Items that may be missing are created along with the basic structure of nodes required to define them."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Procedure Initialization",
        "definition": "The procedure initialization is used to initialize variables used by the procedure loop.",
        "content": [
            {
                "style": "Text",
                "text": "This is an example of a procedure loop code snippet, in particular, the code that initializes the array used in the calculation of the Popular SMAs product of the Simple Moving Average (SMA) indicator."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-js\">"
            },
            {
                "style": "Text",
                "text": "/<i> Initialization Code. </i>/"
            },
            {
                "style": "Text",
                "text": "variable.last200 = []"
            },
            {
                "style": "Text",
                "text": "</code\">"
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a procedure initialization, select <i>Add Procedure Initialization</i> on the corresponding procedure node menu. A procedure initialization node is created along with the corresponding JavaScript node."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Procedure Loop",
        "definition": "The procedure loop holds the JavaScript code that reads an input, processes the information, and generates an output recursively.",
        "content": [
            {
                "style": "Note",
                "text": "Please refer to the coding references page to learn how to code the indicator's logic."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a procedure loop, select <i>Add Procedure loop</i> on the corresponding procedure node menu. A procedure loop node is created along with the corresponding JavaScript node."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Data Building Procedure",
        "definition": "The data building procedure processes information to be fed to properties that are stored in the output dataset.",
        "content": [
            {
                "style": "Text",
                "text": "This procedure holds the core logic of the bot, as it features the code that performs the calculations required to produce the new data set. The code is split between a procedure initialization and a procedure loop."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a data buildings procedure, select <i>Add Missing Items</i> on the product definition node menu. Items that may be missing are created along with the basic structure of nodes required to define them."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Trading Bot",
        "definition": "A trading bot is a computer program that&mdash;based on datasets exposed as products by other bots (counting sensors, indicators and even other trading bots)&mdash;applies the trading logic defined on a trading system to, on one side, generate a complete trading simulation (outputting datasets that include trades, the action of strategies, validation of conditions, etc.), and on the other side, manage the execution of orders when on a forward testing or live trading session.",
        "content": [
            {
                "style": "Text",
                "text": "In Superalgos, a trading bot is a computer program designed to leverage the Superalgos infrastructure to provide smart trading features to users building, testing, and deploying trading systems. As such, a trading bot does not feature trading logic in and of itself. Instead, it executes the logic defined in trading systems."
            },
            {
                "style": "Text",
                "text": "Put in other words, when Superalgos users define trading systems and the trading strategies within, they are not building a trading bot. Instead, they are defining a set of instructions that a trading bot will then interpret and execute."
            },
            {
                "style": "Text",
                "text": "Trading bots have access to every piece of infrastructure built in Superalgos. One of the noteworthy sections of the infrastructure relevant to trading bots are trading mines themselves. Trading bots may be quite complex pieces of software. To name two of the most prominent characteristics: the bot needs to consider multiple dimensions of information and needs to be highly reliable, as its activity entails monetary transactions."
            },
            {
                "style": "Text",
                "text": "Trading mines make building trading bots a more accessible feat, providing a framework to produce compartmentalized definitions for the bots' processes and products, just like data mines do for sensors and indicators."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the trading bot node, select <i>Add Trading Bot</i> on the parent node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "</code\">"
            }
        ],
        "starting": []
    },
    {
        "type": "Learning Bot"
    },
    {
        "type": "Plotter",
        "definition": "A plotter is a device used to produce a graphic representation of datasets generated by bots.",
        "content": [
            {
                "style": "Text",
                "text": "Plotters usually have a one-to-one relationship with bots, as they are often created as a customized solution. However, in practice, there is no constraint to creating any number of plotters for a single bot or a single plotter for multiple bots."
            },
            {
                "style": "Text",
                "text": "The overall workflow of a plotter, while reading a dataset, consists in:"
            },
            {
                "style": "Text",
                "text": "<ul><li>Applying a set of rules to identify certain data points;</li>"
            },
            {
                "style": "Text",
                "text": "<li>Use those points to form lines and polygons;</li>"
            },
            {
                "style": "Text",
                "text": "<li>Apply graphical styles to those lines and polygons.</li>"
            },
            {
                "style": "Text",
                "text": "</ul>"
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a plotter, select <i>Add Plotter</i> on the data mine node menu. An indicator bot is created along with the basic structure of nodes required to define it."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure Plotter</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "  \"codeName\": \"Plotter-Name\""
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">codeName</code> is the name of the plotter as it is used within the bot's code.</li></ul>"
            }
        ],
        "starting": []
    },
    {
        "type": "Trading System",
        "definition": "A trading system is a framework handling the low-level logic that serves to structure the processes and methods used to implement and deploy trading strategies.",
        "content": [
            {
                "style": "Text",
                "text": "In practical terms, a trading system is a hierarchical arrangement organizing the actionable aspects of your investment plan. The hierarchy contains definitions regarding any number of trading strategies, all operating on the same market and sharing the same initial capital allocation."
            },
            {
                "style": "Text",
                "text": "You use a trading system to define strategies following the Superalgos Protocol, splitting strategies into four stages: trigger, open, manage, and close."
            },
            {
                "style": "Text",
                "text": "The concept of describing strategies in stages is fundamental to the methodical aspect of the trading system, as it provides a framework to run every strategy with the same framework, which contributes to developing scalable trading systems that may grow to any number of strategies."
            },
            {
                "style": "Text",
                "text": "When a trading system features more than one strategy, the first strategy has precedence over the second, the second over the third, and so on. This means that strategies are evaluated in a sequence. When a given strategy is triggered-on, the remaining strategies in the queue are no longer evaluated until the strategy triggers off. In other words, when multiple strategies are deployed within a single trading system, only one strategy may trade at any given moment, and precedence is given by the order around the trading system node."
            },
            {
                "style": "Text",
                "text": "As a corollary to the above, if you wish strategies to operate in different markets, or you wish strategies to be able to take positions simultaneously, then you must set up those strategies in different trading systems."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a trading system, select <i>Add Trading System</i> on the other hierarchies node menu in the Superalgos Project hierarchy."
            },
            {
                "style": "Text",
                "text": "{% include tip.html content=\"You may work with as many trading systems as you wish\" %}"
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Trading Strategy",
        "definition": "A trading strategy is the description of a set of actions or events run in stages. Events are triggered upon the validation of precise conditions describing specific market situations. Trading strategies are designed to achieve a specific goal within the broader plan of a trading system via taking and managing positions.",
        "content": [
            {
                "style": "Text",
                "text": "The definition of a strategy may be analyzed in three sections:"
            },
            {
                "style": "Success",
                "text": "A strategy is a set of actions occurring in stages"
            },
            {
                "style": "Text",
                "text": "Strategies are defined in the following stages:"
            },
            {
                "style": "Text",
                "text": "<ul><li>Trigger Stage</li>"
            },
            {
                "style": "Text",
                "text": "<li>Open Stage</li>"
            },
            {
                "style": "Text",
                "text": "<li>Manage Stage</li>"
            },
            {
                "style": "Text",
                "text": "<li>Close Stage</li>"
            },
            {
                "style": "Text",
                "text": "</ul>"
            },
            {
                "style": "Text",
                "text": "While stages are played in a sequence, upon execution there are overlaps. That is, a stage doesn't need to be closed for the next stage to be opened. The framework sets a clear separation of the concepts embodied in each stage to facilitate the process of defining and developing a trading system. But the truth is that, both at the conceptual level and during execution, the lines between stages are rather blurry."
            },
            {
                "style": "Success",
                "text": "designed to achieve a specific goal within a broader plan"
            },
            {
                "style": "Text",
                "text": "Your investment plan or trading career may have any number of goals <i>(e.g.: accumulating a certain asset, diversifying on a basket of coins, annual profit targets, etc.)</i>. If you attempt to achieve more than one goal with a single strategy, you will sooner or later run into problems. It may be doable, but the strategy would certainly be more complex than is necessary or desirable. In any case, the logical thing to do is to analyze each goal separately so that you may design (at least) one clear, straightforward strategy for each goal."
            },
            {
                "style": "Text",
                "text": "One of the edges granted by trading automation is the capacity to develop and deploy an unlimited number of strategies. At the same time, Superalgos allows the administration of complexity by breaking down and structuring concepts in small units: a trading system contains strategies, which contain stages, which contain specific definitions. "
            },
            {
                "style": "Text",
                "text": "Understanding that keeping things simple is important will help you develop a robust and extensible arsenal of bots. Simplicity is the key to sustainability."
            },
            {
                "style": "Text",
                "text": "In other words, the infrastructure provided by Superalgos enables the hyperspecialization of strategies. Do not aim to trade in all sorts of market situations with the same strategy. Instead, develop a strategy for each market situation you wish to trade."
            },
            {
                "style": "Success",
                "text": "via taking and managing positions"
            },
            {
                "style": "Text",
                "text": "The definition of strategy points to the concept of a <i>position</i>. A position is a process that exchanges the base asset for the quoted asset and that—after some time, as the position develops and targets are hit—exchanges back the quoted asset for the base asset."
            },
            {
                "style": "Text",
                "text": "The framework implemented in the Superalgos Protocol is optimized to work with such a concept."
            },
            {
                "style": "Text",
                "text": "However, Superalgos is flexible enough to allow you to override this hard interpretation of the concept of <i>a position</i>. For example, you may design market-making strategies, a strategy to balance portfolios, or develop all sorts of ideas that don't necessarily fit in that part of the definition."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a strategy, select <i>Add Strategy</i> on the trading system node menu. The strategy node is created along with the rest of the basic structure of nodes required to define each of the strategy stages and their events."
            },
            {
                "style": "Text",
                "text": "{% include tip.html content=\"You may work with as many strategies as you wish. \" %}"
            },
            {
                "style": "Important",
                "text": "Strategies within the same trading system work in the same market, have the same base asset, and &mdash;most importantly&mdash;share the same capital. This means that only one strategy in the trading system may be triggered at any one point and that no other strategy in the trading system may be triggered until the first one is triggered off. If you wish to have more than one strategy trading at the same time, then those strategies must be put in separate trading systems. "
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Trigger Stage",
        "definition": "The trigger stage deals with monitoring the market in search of trading opportunities with the corresponding strategy.",
        "content": [
            {
                "style": "Text",
                "text": "A trading system may have multiple strategies designed for the same market."
            },
            {
                "style": "Text",
                "text": "An important aspect of trading systems is that they are allocated a certain amount of capital (see the base asset parameter of the trading session). As a consequence, strategies within a trading system share a certain capital allocation."
            },
            {
                "style": "Text",
                "text": "The logic behind the concept of the trigger stage assumes that different strategies within a trading system may be specialized for trading in different market situations. The trigger stage in each strategy is, therefore, the mechanism by which any particular strategy within the trading system may be selected to trade, given any particular market situation."
            },
            {
                "style": "Text",
                "text": "The triggering-on of a strategy effectively blocks the selection of any other strategy in the trading system and reserves the whole capital allocation for the one strategy selected, until the strategy is triggered-off."
            },
            {
                "style": "Text",
                "text": "Therefore, if certain strategies are meant to trade under the same market situations and open trades concurrently, then those strategies should be deployed in separate trading systems."
            },
            {
                "style": "Text",
                "text": "Once a strategy is triggered, the strategy may decide&mdash;or not&mdash;to take a position. If a position is taken, then the rest of the stages eventually become active."
            },
            {
                "style": "Text",
                "text": "However, the strategy may also be triggered off without taking a position. When a strategy is triggered off, the trading system goes back to monitoring the trigger-on definitions for all strategies, and capital is released to be used by whatever strategy is triggered-on next."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a trigger stage node, select <i>Add Missing Stages</i> on the strategy node menu. All stages that may be missing are created along with the rest of the basic structure of nodes required to define each of them and their events."
            },
            {
                "style": "Note",
                "text": "Only one trigger stage may exist in each strategy."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Trigger On Event",
        "definition": "The trigger-on event defines the set of rules that need to be met for the corresponding strategy to be triggered on. A strategy that is triggered may use all the capital available to the trading system, and prevents other strategies in the system from triggering.",
        "content": [
            {
                "style": "Text",
                "text": "In conceptual terms, the trigger-on event is the mechanism you use to define the specific situations in which you would consider trading with the corresponding strategy. Think of the trigger-on event as the definition of the scenario in which the trading idea behind the strategy should be carefully considered."
            },
            {
                "style": "Text",
                "text": "Once a strategy is triggered-on, the system starts evaluating the take position event. In conceptual terms, it means that the system has been alerted that the trading idea behind the corresponding trading strategy has produced a signal and that it should carefully monitor the market for the opportunity to take a position."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a trigger-on event node, select <i>Add Missing Events</i> on the trigger stage node menu. All events that may be missing are created along with the rest of the basic structure of nodes required to define each of them."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Trigger Off Event",
        "definition": "The trigger-off event defines the situation in which the corresponding strategy shall be triggered-off. A strategy that is triggered-off releases the capital in reserve and makes it available to other strategies in the trading system.",
        "content": [
            {
                "style": "Text",
                "text": "In conceptual terms, the trigger-off event is the mechanism you use to define the situation in which the corresponding strategy should stop considering the trading opportunity signaled by the trigger-on event. That is, you use the trigger off event to describe the scenario for the invalidation of the trading idea behind the strategy."
            },
            {
                "style": "Text",
                "text": "Once a strategy is triggered-on, only two possible scenarios may follow. Either the take position event is triggered, thus, taking a position, or the trigger-off event is triggered first."
            },
            {
                "style": "Text",
                "text": "In the first scenario, the strategy remains <i>on</i> until the position is closed. As the position is closed, the strategy is triggered-off. In the second scenario, the strategy is triggered-off immediately."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a trigger-off event node, select <i>Add Missing Events</i> on the trigger stage node menu. All events that may be missing are created along with the rest of the basic structure of nodes required to define each of them."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Take Position Event",
        "definition": "The take position event defines the situation that needs to be met to take a position.",
        "content": [
            {
                "style": "Text",
                "text": "The trigger-on event merely selects a strategy to be considered for trading under the current market situation. The actual decision to enter a position may require more specific conditions to be met. For that reason, the take position event is a separate entity from the trigger-on event."
            },
            {
                "style": "Text",
                "text": "Therefore, the take position event is defined with its own set of situations and conditions."
            },
            {
                "style": "Text",
                "text": "Once the take position event is triggered, the decision to take a position has been made and there is nothing else to consider in that regard. Therefore, the runtime evaluation of the trading system shifts from the trigger stage to the open stage."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a take position event node, select <i>Add Missing Events</i> on the trigger stage node menu. All events that may be missing are created along with the rest of the basic structure of nodes required to define each of them."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Open Stage",
        "definition": "The open stage deals with the definitions that make up the logic to enter a position, including the target rate and size, and order execution.",
        "content": [
            {
                "style": "Text",
                "text": "The open stage comes into play once the take position event is triggered."
            },
            {
                "style": "Text",
                "text": "Conceptually, the open stage deals with the details concerning how the position shall be opened once the decision to take a position has been made. That is, the open stage does not participate in the process of deciding whether a position should be open or not."
            },
            {
                "style": "Text",
                "text": "To take a position, several definitions are required. In particular, those concerning targets, such as the rate and size of the position, and the logic of the execution strategy, that is, how many of which orders shall be placed at the exchange&mdash;and when&mdash;to enter the position."
            },
            {
                "style": "Text",
                "text": "The open stage closes as soon as one of the following events happen:"
            },
            {
                "style": "Text",
                "text": "<ul><li>the target size gets filled,</li>"
            },
            {
                "style": "Text",
                "text": "<li>the close stage event is triggered,</li>"
            },
            {
                "style": "Text",
                "text": "<li>the take profit or stop loss targets are hit.</li></ul>"
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add an open stage node, select <i>Add Missing Stages</i> on the strategy node menu. All stages that may be missing are created along with the rest of the basic structure of nodes required to define each of them and their events."
            },
            {
                "style": "Note",
                "text": "Only one open stage may exist in each strategy."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Close Stage Event",
        "definition": "The close stage event defines the set of rules that need to be met for the corresponding stage to be closed.",
        "content": [
            {
                "style": "Text",
                "text": "Both the open and close stages are closed once the target size is filled."
            },
            {
                "style": "Text",
                "text": "However, Superalgos allows an extra level of control so that the user may choose to close either stage given specific market situations. Such is the intent of the close stage event."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the close stage event node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Initial Targets",
        "definition": "The initial targets node holds the most basic definitions about the position to be taken: the target rate and the target size.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the initial targets node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Managed Stop Loss",
        "definition": "The managed stop loss node features the definition of the phases that make up the management of the stop loss target as the position develops.",
        "content": [
            {
                "style": "Text",
                "text": "A stop loss target is a crucial element of a trading strategy, as it is the device in charge of preserving capital. Used wisely, the management of the stop loss may also play the role of protecting unrealized profits."
            },
            {
                "style": "Text",
                "text": "The system for managing the stop loss provided by Superalgos is highly flexible. It may start as simple as a constant value at a certain rate, but may switch to a trailing stop as soon as the price moves away from the target rate by a certain percentage, or when a certain market situation arises."
            },
            {
                "style": "Text",
                "text": "In fact, the formula may change as many times as required, as you may set up unlimited phases, and switch back and forth as required using predefined events to make the switch."
            },
            {
                "style": "Note",
                "text": "The above example of a constant stop loss followed by a trailing stop is merely an example of a typical setup. The formulas you use to determine the rate of the target on each phase may be anything you choose, thus, you may achieve whatever behavior you imagine and can describe mathematically."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a stop node, select <i>Add Missing Items</i> on the manage stage node menu. All items that may be missing are created along with the rest of the basic structure of nodes required to define each of them."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Phase",
        "definition": "The management of take profit and stop loss targets is done in phases. Phase 1 sets the initial targets, either for the managed stop loss or the managed take profit, and becomes active as soon as the first order is placed. Subsequent phases allows switching to different formulas given certain market situations.",
        "content": [
            {
                "style": "Text",
                "text": "The default management of phases is sequential, meaning that phase 2 comes after phase 1, phase 3 comes after phase 2, and so on."
            },
            {
                "style": "Text",
                "text": "To switch from one phase to the next phase in the sequence, the next phase event is used. When the situation described in the next phase event validates <code class=\"language-none\">true</code>, the switch occurs and the next phase becomes the active phase."
            },
            {
                "style": "Text",
                "text": "However, management does not need to happen sequentially. By using the move to phase event instead of the next phase event, the system may activate any other phase and not just the one next in the sequence."
            },
            {
                "style": "Text",
                "text": "Both events may be used at the same time, and whichever event is triggered first takes precedence."
            },
            {
                "style": "Note",
                "text": "Notice that stop loss and take profit phases are independent and defined separately from each other, each below the corresponding managed stop loss and managed take profit nodes."
            },
            {
                "style": "Note",
                "text": "The value of the target set for a phase is expressed by a formula. Learn more about formulas and how to write them."
            },
            {
                "style": "Text",
                "text": "{% include tip.html content=\"This explanation about phase 1 may be extended to any other phase, as they all work similarly, and it applies both for managed stop loss phases and managed take profit phases.\" %}"
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a new phase, select <i>Add Phase</i> on the stop or take-profit node menu. A new phase is added along with the basic structure of nodes required to define each of them and their events."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Next Phase Event",
        "definition": "The next phase event determines when there should be a switch of phases to the next phase in a predefined sequence.",
        "content": [
            {
                "style": "Text",
                "text": "The management of a position is &mdash;by default&mdash;done in sequential phases, each phase with its formula. To move from one phase to the next, a situation you define must be validated."
            },
            {
                "style": "Text",
                "text": "When that happens, the next phase event is triggered, the current phase is abandoned, and the next phase is activated. From that instant on, the system evaluates the formula corresponding to the next phase."
            },
            {
                "style": "Text",
                "text": "The sequence of phases may be as long as the number of phases you choose to add and define. There may be unlimited numbers of phases."
            },
            {
                "style": "Note",
                "text": "Events are triggered by situations, which are defined by conditions. Both are explained in the situations, conditions, and formulas page."
            },
            {
                "style": "Text",
                "text": "{% include tip.html content=\"To set up a next phase event, add the node and define the situation that should trigger the event.\" %}"
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a next phase event, select <i>Add Next Phase Event</i> on the corresponding phase node menu. The event is added along with the basic structure of nodes to define it."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Move To Phase Event",
        "definition": "The move to phase event determines when there should be a switch of phases from the current phase to an arbitrary phase determined by a reference.",
        "content": [
            {
                "style": "Text",
                "text": "While phases are defined in a sequence and you may choose to manage the position by shifting from one phase to the next in the sequence, the move to phase event offers an alternative."
            },
            {
                "style": "Text",
                "text": "With the move to phase event, you may arbitrarily decide which will be the next phase. To do that, you must establish a reference from the move to phase event, to the phase that should be activated once the event is triggered."
            },
            {
                "style": "Text",
                "text": "Any number of move-to-phase events may be set up for each and every phase, allowing complete flexibility on how the position is managed. This feature allows setting up versatile position-management algorithms that may switch to different formulas back and forth, or in any configuration imaginable."
            },
            {
                "style": "Note",
                "text": "A move-to-phase event must reference a phase node. When the situation in the move-to-phase event evaluates <code class=\"language-none\">true</code> the management shifts to the referenced phase."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a move-to-phase event, select <i>Add Move to Phase Event</i> on the corresponding phase node menu. The event is added along with the basic structure of nodes to define it."
            },
            {
                "style": "Note",
                "text": "Remember to establish a reference with the phase you wish to activate once the situation associated with the event validates true."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Managed Take Profit",
        "definition": "The managed take profit node features the definition of the phases that make up the management of the take profit target as the position develops.",
        "content": [
            {
                "style": "Text",
                "text": "A take profit target bears an important role in your strategy, as it plays a crucial role in determining the risk/reward ratio of the trading opportunity that materialized, and upon which your strategy acted to take a position."
            },
            {
                "style": "Text",
                "text": "The foremost goal of trading is to increase your capital, and how you set your initial take profit target and manage it afterward determines how much you may increase your capital given a favorable price action."
            },
            {
                "style": "Note",
                "text": "The system provides the same functionality for managing the take profit target as explained for the managed stop loss target, so please make sure you go through that section too. "
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a take profit node, select <i>Add Missing Items</i> on the manage stage node menu. All items that may be missing are created along with the rest of the basic structure of nodes required to define each of them."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Target Size In Base Asset",
        "definition": "Target size in base asset is used to define the size of the position, denominating it in the base asset.",
        "content": [
            {
                "style": "Text",
                "text": "The system supports defining the size of the position in either asset involved in the market: the base asset, or the quoted asset, as per the exchange listing of the market."
            },
            {
                "style": "Text",
                "text": "The target size may be defined in one of the two assets only, to avoid inconsistencies."
            },
            {
                "style": "Text",
                "text": "The target size is the maximum size the position may achieve. That is, the definition of the target size is used as a cap for the total size of orders that may be placed during the open stage."
            },
            {
                "style": "Text",
                "text": "If you prefer to define the size of the position denominated in the base asset, then use this node and delete the target size in quoted asset node."
            },
            {
                "style": "Important",
                "text": "Only one target size definition may exist at a time."
            },
            {
                "style": "Text",
                "text": "Even though the definition of the target size is denominated in one of the two assets in the market, the system keeps track of accounts for both assets. That is, performance metrics such as profit loss, ROI, hit ratio, or the annualized rate of return are calculated both based on the base asset and the quoted asset. In fact, metrics are also calculated in a consolidated manner, taking into account both assets at the same time."
            },
            {
                "style": "Text",
                "text": "All of this information is made available for multiple contexts, for instance, for each position or the whole episode, through the data structure of the trading engine."
            },
            {
                "style": "Text",
                "text": "When tracking the results of your trading operation, make sure you refer to the set of accounts that make sense for your trading system. This will all become clearer once you read about the trading engine and the layer managers available on the charts."
            },
            {
                "style": "Text",
                "text": "<H4>Examples</H4>"
            },
            {
                "style": "Text",
                "text": "If you are trading the whole balance assigned to the trading system on each position, then your target size will look like this:"
            },
            {
                "style": "Text",
                "text": "<code class=\"language-none\">"
            },
            {
                "style": "Text",
                "text": "tradingEngine.current.episode.episodeBaseAsset.balance.value"
            },
            {
                "style": "Text",
                "text": "</code>"
            },
            {
                "style": "Text",
                "text": "... or..."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-none\">"
            },
            {
                "style": "Text",
                "text": "tradingEngine.current.episode.episodeQuotedAsset.balance.value"
            },
            {
                "style": "Text",
                "text": "</code>"
            },
            {
                "style": "Text",
                "text": "If you are not trading the entire balance on each position, then you may define the target size as a percentage of the balances, or in any other way you may see fit. For such cases, the following formula may be  of use for the close stage target size:"
            },
            {
                "style": "Text",
                "text": "<code class=\"language-none\">"
            },
            {
                "style": "Text",
                "text": "tradingEngine.current.strategyOpenStage.stageBaseAsset.sizeFilled.value - tradingEngine.current.strategyOpenStage.stageBaseAsset.feesPaid.value"
            },
            {
                "style": "Text",
                "text": "</code>"
            },
            {
                "style": "Text",
                "text": "Of course, you may need to adjust the above to use <code class=\"language-none\">stageBaseAsset</code> or <code class=\"language-none\">stageQuotedAsset</code>, as required. In short, the formula returns the amount of the asset obtained by the transactions triggered during the open stage, minus the fees (and slippage, which is already subtracted from the size filled)."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the target size in base asset node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Target Size In Quoted Asset",
        "definition": "Target size in quoted asset is used to define the size of the position, denominating it in the quoted asset.",
        "content": [
            {
                "style": "Text",
                "text": "If you prefer to define the size of the position denominated in the quoted asset, then use this node and delete the target size in base asset node."
            },
            {
                "style": "Important",
                "text": "Make sure you read the definition of the target size in base asset node to get the proper context for this definition."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the target size in quoted asset node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Target Rate",
        "definition": "The target rate is a reference rate that may affect simulations and that, in combination with the placement of managed stop loss and managed take profit targets, is used to determine whether the targets have been hit.",
        "content": [
            {
                "style": "Text",
                "text": "<H4>Internal Use</H4>"
            },
            {
                "style": "Text",
                "text": "The system needs to determine when the managed stop loss and managed take profit targets have been hit. To do this, the system observes how the user places the targets in relation to the target rate."
            },
            {
                "style": "Text",
                "text": "<i>For example:</i>"
            },
            {
                "style": "Text",
                "text": "If the phase 1 managed stop loss target is placed below the target rate and the phase 1 managed take profit target above it, the system assumes that:"
            },
            {
                "style": "Text",
                "text": "<ul><li>the stop loss target is hit when the current rate is equal to or smaller than the managed stop loss value;</li>"
            },
            {
                "style": "Text",
                "text": "<li>the stop loss target is hit when the current rate is equal to or greater than the managed take profit value;</li>"
            },
            {
                "style": "Text",
                "text": "</ul>"
            },
            {
                "style": "Text",
                "text": "This is how the system uses the target rate internally."
            },
            {
                "style": "Text",
                "text": "<H4>Fetching the Value from Formulas</H4>"
            },
            {
                "style": "Text",
                "text": "Additionally, defining a target rate at the level of the stage may be of use so that you may retrieve the value from formulas while setting the rate of limit orders, using the path of the corresponding node at the trading engine."
            },
            {
                "style": "Text",
                "text": "For example, <code class=\"language-none\">tradingEngine.current.position.entryTargetRate.value</code> or <code class=\"language-none\">tradingEngine.current.position.exitTargetRate.value</code>."
            },
            {
                "style": "Text",
                "text": "<H4>Affecting How Simulations are Plotted</H4>"
            },
            {
                "style": "Text",
                "text": "The target rates defined at the open and close stages affect how the <i>Posittion Base Asset</i> and <i>Position Quoted Asset</i> layers in the <i>Simulation Objects</i> layer manager draw the triangle representing the development of the trade."
            },
            {
                "style": "Text",
                "text": "{% include image.html file='trading-system/target-rate-in-position.png' url='yes' max-width='100' caption='The Position Base Asset layer is on, providing a visual clue of how the position developed.' %}"
            },
            {
                "style": "Text",
                "text": "The horizontal segment marks the target rate defined at the open stage. If you are using market orders to take the position, then using <code class=\"language-none\">tradingEngine.current.episode.candle.close.value</code> may offer a good representation of the rate of market orders. If you are using limit orders, then you may decide at which rate you wish to take the position, and the horizontal segment of the triangle will match the chosen rate."
            },
            {
                "style": "Text",
                "text": "The third vertex of the triangle points to a <code class=\"language-none\">[datetime, rate]</code> coordinate. The <code class=\"language-none\">datetime<code class=\"language-none\"> is given by the candle on which the manage stage closes, that is, the candle at which the stop loss or take profit targets are hit. The </code>rate</code> portion of the coordinate is given by the target rate defined in the close stage."
            },
            {
                "style": "Text",
                "text": "You may choose to apply a similar reasoning as with the open stage target rate for limit orders, but there is some nouance to consider if you are using market orders."
            },
            {
                "style": "Success",
                "text": "The issue arises if you when you run a testing session at a time frame higher than the time frame you use for live trading."
            },
            {
                "style": "Text",
                "text": "Why is that an issue?"
            },
            {
                "style": "Text",
                "text": "Let's say your trading system makes decisions based on the close of the 1-hour candle. And let's say you are using stop loss and take profit targets. In such cases&mdash;when live trading&mdash;you may want to run your strategy in the 1-minute time frame, to detect the tagging of the take profit and stop targets as soon as possible, and act accordingly."
            },
            {
                "style": "Text",
                "text": "However, when backtesting, it is much faster to run sessions on the 1-hour time frame. This is particularly important when you wish to test significant time ranges."
            },
            {
                "style": "Text",
                "text": "When backtesting a strategy on the 1-hour time frame, the trading bot evaluates if stop loss and take profit targets have been hit at the close of the 1-hour candle, and may only act upon the evaluation on the next candle. This means that if you are using market orders to exit the position, the market order would be placed (in the simulation!) on the candle after one of the targets was hit."
            },
            {
                "style": "Text",
                "text": "The difference in rate between the moment in time the target is hit and the time the 1-hour candle closes may be significant. As a result, if the close stage target rate is defined as <code class=\"language-none\">tradingEngine.current.episode.candle.close.value</code>, the resulting simulation may show significant slippage, and diverge from what the trade would look like if running on the 1-minute time frame, like you would when trading live."
            },
            {
                "style": "Text",
                "text": "To solve the above issue, you may use a more ellaborate formula for the target rate in the close stage:"
            },
            {
                "style": "Text",
                "text": "<code class=\"language-js\">"
            },
            {
                "style": "Text",
                "text": "targetRate()"
            },
            {
                "style": "Text",
                "text": "function targetRate() {"
            },
            {
                "style": "Text",
                "text": "    switch (tradingEngine.current.position.exitType.value) {"
            },
            {
                "style": "Text",
                "text": "        case 'No Exit': {"
            },
            {
                "style": "Text",
                "text": "            return tradingEngine.current.episode.candle.close.value"
            },
            {
                "style": "Text",
                "text": "            break"
            },
            {
                "style": "Text",
                "text": "        }"
            },
            {
                "style": "Text",
                "text": "        case 'Take Profit': {"
            },
            {
                "style": "Text",
                "text": "            return tradingEngine.current.position.takeProfit.finalValue.value"
            },
            {
                "style": "Text",
                "text": "            break"
            },
            {
                "style": "Text",
                "text": "        }"
            },
            {
                "style": "Text",
                "text": "        case 'Stop Loss': {"
            },
            {
                "style": "Text",
                "text": "            return tradingEngine.current.position.stopLoss.finalValue.value"
            },
            {
                "style": "Text",
                "text": "            break"
            },
            {
                "style": "Text",
                "text": "        }"
            },
            {
                "style": "Text",
                "text": "    }"
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "This formula discriminates among three possible outcomes:"
            },
            {
                "style": "Text",
                "text": "<ul><li>When the no target has been hit, the value of the target rate is the close of the current candle.</li>"
            },
            {
                "style": "Text",
                "text": "<li>When the take profit is hit, the value of the target rate is the last value of the take profit.</li>"
            },
            {
                "style": "Text",
                "text": "<li>When the stop loss is hit, the value of the target rate is the last value of the stop loss.</li>"
            },
            {
                "style": "Text",
                "text": "</ul>"
            },
            {
                "style": "Text",
                "text": "{% include tip.html content=\"You may use a similar formula on the simulated actual rate node of the simulated exchange events associated with the market order you are using to exit the position. Such use of the simulated actual rate node would impact the accounts kept for the episode and result in more realistic results for your backtesting session.\" %}"
            },
            {
                "style": "Note",
                "text": "As you see, flexibility is a key design feature in Superalgos."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the target rate node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Order Rate",
        "definition": "The order rate node defines the rate of limit orders.",
        "content": [
            {
                "style": "Text",
                "text": "Because the purpose of limit orders is to have control over the rate at which the order is executed, the definition of the order rate is required for all limit orders."
            },
            {
                "style": "Note",
                "text": "Please, read about limit orders to complement the information in this definition."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the order rate node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Open Execution",
        "definition": "The open execution node groups all execution algorithms involved in the process of opening a position.",
        "content": [
            {
                "style": "Text",
                "text": "One of the crucial elements that make up trading intelligence is the capacity to control every aspect of order execution, as the execution itself entails strategic elements that directly affect performance."
            },
            {
                "style": "Text",
                "text": "Superalgos' trading engine is designed as a generic infrastructure that allows building execution logic from the ground up, with as much simplicity or complexity as may be required."
            },
            {
                "style": "Text",
                "text": "The trading system splits the definitions of the execution logic by trading strategy. That is, each strategy in a trading system may have its execution logic."
            },
            {
                "style": "Text",
                "text": "The next layer of control comes in the form of execution algorithms. Each strategy may have as many algorithms as required, and each algorithm may have as many instructions as required."
            },
            {
                "style": "Text",
                "text": "This model allows the granular control of orders with which you may build algorithms that may interact with other algorithms, and so on."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the open execution node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Execution Algorithm",
        "definition": "An execution algorithm is a set of instructions used to place and manage orders at the exchange.",
        "content": [
            {
                "style": "Text",
                "text": "Any given strategy may have simple or very complex execution requirements. To deal with complexity, Superalgos allows users to set up as many execution algorithms as required."
            },
            {
                "style": "Text",
                "text": "Then, the logic in each algorithm may remain simple, while the combined work of multiple algorithms may deal with the required complexity."
            },
            {
                "style": "Text",
                "text": "Each algorithm may be assigned a fraction of the target size (see the configuration section), thus, the extent of each algorithm's involvement in the execution is defined by this parameter."
            },
            {
                "style": "Text",
                "text": "An execution algorithm is a set of instructions in the sense that the orders defined in each algorithm are themselves the instructions. That is, an execution algorithm is a set of predefined orders which may be created or canceled given specific market situations."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the execution algorithm node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "To configure the execution algorithm node, select <i>Configure</i> on the menu."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "     \"percentageOfStageTargetSize\": 100"
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">percentageOfStageTargetSize</code> is the definition of how much of the target size of the whole stage will be handled by the one specific execution algorithm, expressed as a percentage of the total target size. Posible values are real numbers between <code class=\"language-none\">0<code class=\"language-none\"> and </code>100</code>, including the extremes. If you set the value to <code class=\"language-none\">0</code>, the algorithm will not be executed.</li></ul>"
            }
        ],
        "starting": []
    },
    {
        "type": "Market Buy Order",
        "definition": "A market buy order is an instruction sent to the exchange to buy the base asset, for immediate execution at current market prices.",
        "content": [
            {
                "style": "Text",
                "text": "Traders usually use market orders when the priority is the certainty of execution over the rate of execution. Depending on the size of the order and the liquidity of the particular market/exchange, market orders may experience more or less slippage."
            },
            {
                "style": "Text",
                "text": "###### Market Orders' Rate"
            },
            {
                "style": "Text",
                "text": "Users have no control over the rate at which a market order is filled. The exchange fills the order with available bids/asks at the time of execution."
            },
            {
                "style": "Text",
                "text": "{% include tip.html content=\"The information below this banner is valid for all types of orders.\" %}"
            },
            {
                "style": "Text",
                "text": "###### Order Size"
            },
            {
                "style": "Text",
                "text": "As explained in the definition of the execution algorithm, each algorithm is allocated a percentage of the target size defined under the initial targets node."
            },
            {
                "style": "Text",
                "text": "<i>The simplified logic for non-coders:</i>"
            },
            {
                "style": "Text",
                "text": "<code class=\"language-none\">algorithmSize = targetSize * percentageOfStageTargetSize / 100</code>"
            },
            {
                "style": "Text",
                "text": "<i>The actual code:</i>"
            },
            {
                "style": "Text",
                "text": "<code class=\"language-js\">"
            },
            {
                "style": "Text",
                "text": "let algorithmSizeInBaseAsset = tradingEngineStage.stageBaseAsset.targetSize.value * executionAlgorithm.config.percentageOfStageTargetSize / 100"
            },
            {
                "style": "Text",
                "text": "let algorithmSizeInQuotedAsset = tradingEngineStage.stageQuotedAsset.targetSize.value * executionAlgorithm.config.percentageOfStageTargetSize / 100"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "Similarly, the size of an order is defined as a percentage of the size that the particular algorithm is allowed to execute <i>(see the configuration)</i>."
            },
            {
                "style": "Text",
                "text": "<i>The simplified logic for non-coders:</i>"
            },
            {
                "style": "Text",
                "text": "<code class=\"language-none\">orderSize = algorithmSize * percentageOfAlgorithmSize / 100</code>"
            },
            {
                "style": "Text",
                "text": "<i>The actual code:</i>"
            },
            {
                "style": "Text",
                "text": "<code class=\"language-js\">"
            },
            {
                "style": "Text",
                "text": "tradingEngineOrder.orderBaseAsset.size.value = algorithmSizeInBaseAsset * tradingSystemOrder.config.percentageOfAlgorithmSize / 100"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "Because each execution algorithm may define multiple orders, the typical scenario is that all orders defined within an algorithm add up to 100% of the size allocated to the algorithm."
            },
            {
                "style": "Text",
                "text": "However, it is up to the user how to manage this setting, as different hacks may be found to achieve different behaviors."
            },
            {
                "style": "Success",
                "text": "If orders defined add up to more than 100% of the size allocated to the algorithm, the trading engine does not enforce a cap."
            },
            {
                "style": "Text",
                "text": "Pretty much like the user may decide to define the size of orders within an algorithm above or below the 100% mark, the same is true when defining multiple algorithms. In other words, the user may choose to set up algorithms whose combined sizes amount to more or less than 100%."
            },
            {
                "style": "Text",
                "text": "In cases in which the combined sizes amount to less than 100%, the target size would be partially filled at best. On the other hand, in cases in which the combined sizes amount to more than 100%, then the orders and/or algorithms would compete with each other."
            },
            {
                "style": "Success",
                "text": "The one validation the trading engine does is to enforce the target size defined under the initial targets node. The target size is treated as a hard cap, so that no position may ever be sized larger than the target."
            },
            {
                "style": "Text",
                "text": "If the order size as defined would cause the target size to be breached, then the order size is lowered to match the hard cap."
            },
            {
                "style": "Text",
                "text": "<i>The simplified logic for non-coders:</i>"
            },
            {
                "style": "Text",
                "text": "<code class=\"language-js\">"
            },
            {
                "style": "Text",
                "text": "if   ( targetSize + sizePlaced > targetSize )"
            },
            {
                "style": "Text",
                "text": "     { orderSize = targetSize - sizePlaced }"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<i>The actual code:</i>"
            },
            {
                "style": "Text",
                "text": "<code class=\"language-js\">"
            },
            {
                "style": "Text",
                "text": "if ("
            },
            {
                "style": "Text",
                "text": "     tradingEngineOrder.orderBaseAsset.size.value + tradingEngineStage.stageBaseAsset.sizePlaced.value >"
            },
            {
                "style": "Text",
                "text": "     tradingEngineStage.stageBaseAsset.targetSize.value"
            },
            {
                "style": "Text",
                "text": "   ) {"
            },
            {
                "style": "Text",
                "text": "     tradingEngineOrder.orderBaseAsset.size.value = tradingEngineStage.stageBaseAsset.targetSize.value - tradingEngineStage.stageBaseAsset.sizePlaced.value"
            },
            {
                "style": "Text",
                "text": "   }"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Note",
                "text": "See the order's configuration to learn how to set up the order size."
            },
            {
                "style": "Text",
                "text": "###### Placing and Filling of Orders"
            },
            {
                "style": "Text",
                "text": "The trading engine keeps track of the amounts placed and the amounts filled based on the feedback obtained from the exchange, and makes the information available in the size placed and size filled nodes. The nodes are present in multiple contexts, such as the particular stage (open and close) or the particular order type, and are denominated both in the base asset and quoted asset. You may learn more about how to track the size placed and size filled on the trading engine pages."
            },
            {
                "style": "Text",
                "text": "###### Closing of Orders"
            },
            {
                "style": "Text",
                "text": "Orders may be closed upon the occurrence of the following two events:"
            },
            {
                "style": "Text",
                "text": "<ul><li>The exchange reports the order was filled. In such a case, the trading engine closes the order.</li>"
            },
            {
                "style": "Text",
                "text": "<li>The cancel order event is triggered. This is an event the user may configure with the typical set up of situations and conditions.</li>"
            },
            {
                "style": "Text",
                "text": "</ul>"
            },
            {
                "style": "Text",
                "text": "All of the available types of orders may be configured so that multiple orders may be spawned, one after the other, through the same order definition."
            },
            {
                "style": "Text",
                "text": "This allows, for example, setting an order for 1% of the size allocated to the algorithm, and have the trading engine spawn one order per execution cycle until the 100% mark is reached. Such a feature may allow many more hacks and is yet another tool that&mdash;combined with the rest&mdash;enables a great deal of control over orders execution."
            },
            {
                "style": "Text",
                "text": "A new instance of an order may be spawned only under the following  context:"
            },
            {
                "style": "Text",
                "text": "<ul><li>The previous instance of the order is closed. That is, two instances of the same order may not exist at the same time.</li>"
            },
            {
                "style": "Text",
                "text": "<li>The size filled at the level of the execution algorithm is within the limit established in the algorithm's configuration.</li>"
            },
            {
                "style": "Text",
                "text": "<li>The size filled at the level of the stage must be within the target size defined under the initial targets node.</li>"
            },
            {
                "style": "Note",
                "text": "</ul>"
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the market buy order node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "To configure the market buy order node, select <i>Configure</i> on the menu."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "     \"percentageOfAlgorithmSize\": 100,"
            },
            {
                "style": "Text",
                "text": "     \"spawnMultipleOrders\": false"
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">percentageOfAlgorithmSize</code> is the definition of how much of the size handled by the algorithm shall be allocated to this particular order. Posible values are real numbers between <code class=\"language-none\">0<code class=\"language-none\"> and </code>100</code>, including the extremes. If you set the value to <code class=\"language-none\">0</code>, the order will not be executed.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">spawnMultipleOrders</code> is the parameter that indicates whether additional spawned orders are allowed (<code class=\"language-none\">true<code class=\"language-none\">) or not (</code>false</code>).</li></ul>"
            }
        ],
        "starting": []
    },
    {
        "type": "Market Sell Order",
        "definition": "A market sell order is an instruction sent to the exchange to sell the base asset, for immediate execution at current market prices.",
        "content": [
            {
                "style": "Text",
                "text": "{% include tip.html content=\"Please read the definition of market buy order for relevant information about how orders in general&mdash;and market orders in particular&mdash;work. \" %}"
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the market sell order node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "To configure the market sell order node, select <i>Configure</i> on the menu."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "     \"percentageOfAlgorithmSize\": 100,"
            },
            {
                "style": "Text",
                "text": "     \"spawnMultipleOrders\": false"
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">percentageOfAlgorithmSize</code> is the definition of how much of the size handled by the algorithm shall be allocated to this particular order. Posible values are real numbers between <code class=\"language-none\">0<code class=\"language-none\"> and </code>100</code>, including the extremes. If you set the value to <code class=\"language-none\">0</code>, the order will not be executed.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">spawnMultipleOrders</code> is the parameter that indicates whether additional spawned orders are allowed (<code class=\"language-none\">true<code class=\"language-none\">) or not (</code>false</code>).</li></ul>"
            }
        ],
        "starting": []
    },
    {
        "type": "Limit Buy Order",
        "definition": "A limit buy order is an instruction sent to the exchange to buy the base asset, for execution at a specific rate or better.",
        "content": [
            {
                "style": "Text",
                "text": "Traders usually use limit orders when the priority is the rate of execution over the certainty of execution. Limit orders are much more efficient than market orders in terms of rate, particularly for larger sizes which&mdash;when executed as market orders&mdash;may suffer considerable slippage filled as fast as possible with the order book of the particular instant."
            },
            {
                "style": "Text",
                "text": "Also, many exchanges regard limit orders as market makers, that is, orders that bring liquidity to the market, and, therefore, may charge relatively better fees."
            },
            {
                "style": "Text",
                "text": "###### Limit Orders' Rate"
            },
            {
                "style": "Text",
                "text": "Superalgos users must define the rate at wish they wish the order to be filled. The exchange is responsible for not filling the order unless it can match it with bids/asks at the rate set by the user, or at a better rate."
            },
            {
                "style": "Text",
                "text": "Small discrepancies between the actual rate and the order rate are to be expected, as not all exchanges handle decimals and other conversions involving, for example, fees, in the same manner."
            },
            {
                "style": "Note",
                "text": "Limit orders must define a rate using the appropriate child node, otherwise, the target rate defined as an initial target is used. If no rate is defined at all, the system stops with an error upon execution. The configuration of the order deals with the size. "
            },
            {
                "style": "Text",
                "text": "{% include tip.html content=\"Please read the definition of market buy order for relevant information about how orders in general work, in particular, the section about Order Size, Filling of Orders, Closing of Orders, and Spawning Multiple Orders. \" %}"
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the limit buy order node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "To configure the limit buy order node, select <i>Configure</i> on the menu."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "     \"percentageOfAlgorithmSize\": 100,"
            },
            {
                "style": "Text",
                "text": "     \"spawnMultipleOrders\": false"
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">percentageOfAlgorithmSize</code> is the definition of how much of the size handled by the algorithm shall be allocated to this particular order. Posible values are real numbers between <code class=\"language-none\">0<code class=\"language-none\"> and </code>100</code>, including the extremes. If you set the value to <code class=\"language-none\">0</code>, the order will not be executed.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">spawnMultipleOrders</code> is the parameter that indicates whether additional spawned orders are allowed (<code class=\"language-none\">true<code class=\"language-none\">) or not (</code>false</code>).</li></ul>"
            }
        ],
        "starting": []
    },
    {
        "type": "Limit Sell Order",
        "definition": "A limit sell order is an instruction sent to the exchange to sell the base asset, for execution at a specific rate or better.",
        "content": [
            {
                "style": "Text",
                "text": "{% include tip.html content=\"Please read the definition of limit buy order for relevant information about how limit orders work. Also, please read the definition of "
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the limit sell order node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "To configure the limit sell order node, select <i>Configure</i> on the menu."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "     \"percentageOfAlgorithmSize\": 100,"
            },
            {
                "style": "Text",
                "text": "     \"spawnMultipleOrders\": false"
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">percentageOfAlgorithmSize</code> is the definition of how much of the size handled by the algorithm shall be allocated to this particular order. Posible values are real numbers between <code class=\"language-none\">0<code class=\"language-none\"> and </code>100</code>, including the extremes. If you set the value to <code class=\"language-none\">0</code>, the order will not be executed.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">spawnMultipleOrders</code> is the parameter that indicates whether additional spawned orders are allowed (<code class=\"language-none\">true<code class=\"language-none\">) or not (</code>false</code>).</li></ul>"
            }
        ],
        "starting": []
    },
    {
        "type": "Create Order Event",
        "definition": "The create order event controls the placement of orders.",
        "content": [
            {
                "style": "Text",
                "text": "Even though the decision to take a position may have been made, the user may still decide to exert additional control over the placement of orders. Such is the intent of the create order event."
            },
            {
                "style": "Text",
                "text": "An order defined in an execution algorithm will be executed only if the event evaluates <code class=\"language-none\">true</code>."
            },
            {
                "style": "Text",
                "text": "If you wish orders to be placed as defined immediately after the take position event has been triggered, the use the statement <code class=\"language-none\">true</code> your only create order event condition."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the create order event node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Cancel Order Event",
        "definition": "The cancel order event makes cancelling limit orders possible.",
        "content": [
            {
                "style": "Text",
                "text": "The cancel order event defines the market situations in which a limit order shall be canceled. When the event is triggered, the order is closed, even when the order may have been partially filled. In such a case, the size filled remains as is, and all accounts are computed accordingly, with the partial fill."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the cancel order event node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Simulated Exchange Events",
        "definition": "The simulated exchange event node allows to override the parameters set at the level of the trading session on a per order basis to determine how each order shall be simulated.",
        "content": [
            {
                "style": "Text",
                "text": "The offspring nodes under simulated exchange events allow setting order-specific parameters for the size filled, actual rate, and fees paid, so that each order may be simulated in a specific manner."
            },
            {
                "style": "Text",
                "text": "If either of the offspring nodes is not present or is undefined, then the parameters configured at the level of the trading session are factored in by default."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the simulated exchange events node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Simulated Partial Fill",
        "definition": "The simulated partial fill parameter allows simulating the partial fill of orders.",
        "content": [
            {
                "style": "Text",
                "text": "Upon each execution, the simulation verifies if the current candle intersects the rate set for the order. If it does, it uses the value in this parameter as a factor to determine and keep track of what percentage of the order is filled."
            },
            {
                "style": "Text",
                "text": "The same process repeats for each subsequent candle, until the order is filled."
            },
            {
                "style": "Text",
                "text": "When the parameter is not present or undefined, the simulation assumes the order is filled as soon as the rate is hit."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the simulated partial fill node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "To configure the simulated partial fill node, select <i>Configure</i> on the menu."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "     \"fillProbability\": 1"
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">fillProbability</code> indicates the probability of an order getting filled upon each tag of the price. Values may range from <code class=\"language-none\">0<code class=\"language-none\"> to </code>1</code>. The value <code class=\"language-none\">0</code> indicates that there are 0% chances of the order getting filled. With such a setting, the order will never get filled in the simulation.  The value <code class=\"language-none\">1<code class=\"language-none\"> indicates that there is a 100% probability of the order getting filled. With such a setting, the order is filled upon the first tag of the price. A value of </code>0.5</code> indicates a 50% probability, thus, it takes two tags of the price for the order to fill completely with such a setting.</li></ul>"
            }
        ],
        "starting": []
    },
    {
        "type": "Simulated Actual Rate",
        "definition": "The simulated actual rate node allows setting a specific rate value for the simulation of each order, overriding the slippage parameter of the trading session.",
        "content": [
            {
                "style": "Text",
                "text": "The slippage parameter of the trading session allows setting a blanket slippage for all orders in the trading system. The simulated actual rate node allows control on a per-order basis, so each order may be simulated with a specific rate."
            },
            {
                "style": "Note",
                "text": "If the node is not present or the parameter is undefined, the slippage parameter set up for the trading session is used."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the simulated actual rate node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Simulated Fees Paid",
        "definition": "The simulated fees paid node allows setting a specific fee for the simulation of each order, overriding the fee structure parameter of the trading session.",
        "content": [
            {
                "style": "Text",
                "text": "The fee structure parameter of the trading session allows setting a blanket fee structure (maker and taker) for all orders in the trading system. The simulated fees paid node allows control on a per-order basis, so each order may be simulated with a specific fee."
            },
            {
                "style": "Note",
                "text": "If the node is not present or the parameter is undefined, the fee structure parameter set up for the trading session is used."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the simulated fees paid node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "To configure the simulated fees paid node, select <i>Configure</i> on the menu."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "\"percentage\": 0.1"
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">percentage</code> is the percentage to be applied to calculate the fees for the specific order.</li></ul>"
            }
        ],
        "starting": []
    },
    {
        "type": "Manage Stage",
        "definition": "The manage stage deals with the setting and management of stop loss and take profit targets, both to protect your capital and to increase the efficiency of your trading system.",
        "content": [
            {
                "style": "Text",
                "text": "The first and foremost rule of trading is to preserve capital and its main goal is to increase it."
            },
            {
                "style": "Text",
                "text": "Conceptually, a position is not an instantaneous event, but an event which has an opening, a period of maturation, and a closing. The management of the position happens throughout the process."
            },
            {
                "style": "Text",
                "text": "The concept of managing the position refers to the fact that the formulas that determine the take profit and stop loss targets may change as the position develops. A typical situation in which you may want to change your original take profit and stop loss formulas is when the position seems to be developing well in your favor."
            },
            {
                "style": "Text",
                "text": "It may be in your best interest to manage the stop loss, moving the target in the direction that would help protect unrealized profits. It may also be in your interest to move the take profit target to extract a larger profit than originally expected. Or you may wish to set up a mechanism that closes the trade as soon as a certain market situation materializes."
            },
            {
                "style": "Text",
                "text": "The management of take profit and stop loss is done independently of each other, in phases. Therefore, each concept has its own set of management phases."
            },
            {
                "style": "Text",
                "text": "Each phase has its formula to describe the corresponding target. Users may define situations in which the current phase shall be abandoned and a different phase&mdash;with its formula&mdash;shall be implemented."
            },
            {
                "style": "Text",
                "text": "Keep in mind that the position is in constant development, so there may be as many phases as you deem appropriate for your particular strategy."
            },
            {
                "style": "Text",
                "text": "The idea of managing targets in phases derives from the notion that big market moves tend to provide clues as to what may come up next. For instance, rallies may accelerate as more traders join the move. Recognizable patterns may emerge. Signs of exhaustion may be identified."
            },
            {
                "style": "Text",
                "text": "All of these considerations may feed the dynamic analysis performed in each phase as the position develops."
            },
            {
                "style": "Text",
                "text": "Upon execution, the system verifies if the current candle has tagged either of the targets. If&mdash;or when&mdash;it does, the close stage kicks in and closing execution begins."
            },
            {
                "style": "Success",
                "text": "It is crucial to understand that Superalgos does not place orders to close a position until the stop loss or take profit targets are hit. That is, stop loss and take profit are not orders sitting at the exchange waiting to be filled at a certain rate. Instead, Superalgos keeps track of targets internally, and places the orders at the exchange during the execution cycle in which it detects either of the targets has been hit."
            },
            {
                "style": "Text",
                "text": "This behavior has advantages and disadvantages, but it was designed as is because the former outweigh the latter."
            },
            {
                "style": "Text",
                "text": "By not placing stop or take profit orders at the exchange, Superalgos keeps your targets&mdash;and the underlying strategy&mdash;secret. This guarantees that such a crucial piece of information may not be used against you by the exchange itself or any third party that may have access to privileged information."
            },
            {
                "style": "Text",
                "text": "On the other hand, not placing a stop order in advance may occasionally cause relatively more slippage, for instance, in cases of massive flash market moves."
            },
            {
                "style": "Text",
                "text": "That said, the default behavior of the system may be hacked to avoid the eventual risk of excessive slippage: set your stop loss and take profit targets tighter than intended."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a manage stage node, select <i>Add Missing Stages</i> on the strategy node menu. All stages that may be missing are created along with the rest of the basic structure of nodes required to define each of them and their events."
            },
            {
                "style": "Note",
                "text": "Only one manage stage may exist in each strategy."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Close Stage",
        "definition": "The close stage deals with the definitions that make up the logic to close a position, including the target rate and size, and order execution.",
        "content": [
            {
                "style": "Text",
                "text": "The close stage is opened when either the stop loss or take profit targets are hit."
            },
            {
                "style": "Text",
                "text": "In a way, the close stage is virtually a mirror of the open stage, as the same definitions are required to close a position. There are a few logical differences, though."
            },
            {
                "style": "Text",
                "text": "For example, in the open stage, you probably defined the target size as a function of the capital allocated to the trading system. In the close stage, you will likely want to define the target size as a function of the size filled, that is, the amount of the orders placed that was filled during the open stage."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a close stage node, select <i>Add Missing Stages</i> on the strategy node menu. All stages that may be missing are created along with the rest of the basic structure of nodes required to define each of them and their events."
            },
            {
                "style": "Note",
                "text": "Only one close stage may exist in each strategy."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Close Execution",
        "definition": "The close execution node groups all execution algorithms involved in the process of closing a position.",
        "content": [
            {
                "style": "Text",
                "text": "The close execution section of the close stage works similarly to the open execution in the open stage. Please refer to the explanations of the open stage for the details."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a close execution node, select <i>Add Close Execution</i> on the open stage node menu."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Social Bots"
    },
    {
        "type": "Telegram Bot"
    },
    {
        "type": "Announcement"
    },
    {
        "type": "Announcement Condition"
    },
    {
        "type": "Crypto Ecosystem",
        "definition": "The crypto ecosystem is a hierarchy that contains definitions about third-parties, including exchanges and their markets, as well as accounts of users with those third parties.",
        "content": [
            {
                "style": "Text",
                "text": "There is only one crypto ecosystem hierarchy. You will use it to define which exchanges and which markets you wish to work with, as well as the details of your accounts with those exchanges."
            }
        ],
        "adding": [],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Super Actions"
    },
    {
        "type": "Signals Providers"
    },
    {
        "type": "Signals Provider"
    },
    {
        "type": "Crypto Exchanges",
        "definition": "The crypto exchanges node groups definitions of the different exchanges the user may interact with.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add a crypto exchanges node, select <i>Add Crypto Exchanges</i> on the crypto ecosystem node menu."
            },
            {
                "style": "Note",
                "text": "Only one crypto exchanges node may exist on the hierarchy."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Crypto Exchange",
        "definition": "A crypto exchange node holds the definitions of assets and markets in a specific exchange.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add a crypto exchange, select <i>Add Crypto Exchange</i> on the crypto exchanges node menu. The crypto exchange node is created along with the rest of the basic structure of nodes required to define assets, markets and user accounts."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure Crypto Exchange</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "    \"codeName\": \"binance\","
            },
            {
                "style": "Text",
                "text": "    \"API\": ["
            },
            {
                "style": "Text",
                "text": "        {"
            },
            {
                "style": "Text",
                "text": "            \"method\": \"fetchTrades\","
            },
            {
                "style": "Text",
                "text": "            \"fetchType\": \"by Id\","
            },
            {
                "style": "Text",
                "text": "            \"fetchTradesMethod\": \"publicGetHistoricalTrades\","
            },
            {
                "style": "Text",
                "text": "            \"firstId\": \"f\""
            },
            {
                "style": "Text",
                "text": "        }"
            },
            {
                "style": "Text",
                "text": "    ]"
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">codeName</code> is the name of the exchange as handled in the code of the system.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">API</code> holds a series of definitions used only in the case in which the sensor bot fetches trades (using the Historic-Trades process) instead of the OHLCV process that fetches one-minute candles and is the current default. In such a case, finding the right set of parameters to work with a specific exchange may be challenging, nd involves understanding how the exchanges API and the CCXT Library API work. In other words, there is no hard rule as of what each of the values should be. Determining each of this values requires exploring the exchange's API documentation, as well as the documentation of the CCXT Library.</li></ul>"
            }
        ],
        "starting": []
    },
    {
        "type": "Exchange Assets",
        "definition": "The exchange assets node groups the definitions of assets.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add an exchange assets node, select <i>Add Exchange Assets</i> on the crypto exchanges node menu. The exchange assets node is created along with a first asset."
            },
            {
                "style": "Note",
                "text": "Only one exchange assets node may exist on each exchange."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure Exchange Assets</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "\"addMissingAssets\": { \"quotedAsset\": \"BTC\"}"
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<i> <code class=\"language-none\">addMissingAssets</code> acts as a filter to determine which assets of a (potentially long) list of assets listed at the exchange will be added when the </i>Add Missing Assets* option in the menu is used. Because many exchanges do not offer a list of assets, the system fetches assets from actual markets (pairs) listed at the exchange. You may add missing assets filtered by the <code class=\"language-none\">quotedAsset<code class=\"language-none\"> or by the </code>baseAsset</code>. For example, the above configuration would add all assets listed in markets in which BTC is the quoted asset."
            }
        ],
        "starting": []
    },
    {
        "type": "Asset",
        "definition": "An asset node is the definition of an asset listed at the corresponding exchange.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add an asset, select <i>Add Asset</i> on the exchange assets node menu."
            },
            {
                "style": "Text",
                "text": "To add assets in bulk, select <i>Add Missing Assets</i> on the exchange assets node menu. Beware that the exchange may handle hundreds of assets. Before using this option you may want to implement a filter using the exchange assets configuration."
            },
            {
                "style": "Text",
                "text": "{% include /crypto_ecosystem/exchange-assets.md heading=\"\" icon=\"no\" adding=\"\" configuring=\"#####\" starting=\"\" content=\"no\" definition=\"no\" table=\"\" more=\"yes\"%}"
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure Asset</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "\"codeName\": \"BTC\""
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<i> <code class=\"language-none\">codeName</code> is the ticker of the asset as listed by the exchange (</i>i.e.:* BTC, BTH, ETH, LTC, BNB, USDT, USD, etc.)"
            },
            {
                "style": "Note",
                "text": "When a configured asset is within the system's icon catalog, the standard asset icon is replaced with the logotype of the corresponding asset."
            }
        ],
        "starting": []
    },
    {
        "type": "Exchange Markets",
        "definition": "The exchange markets node groups the definitions of markets.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add an exchange markets node, select <i>Add Exchange Markets</i> on the crypto exchange node menu. The exchange markets node is created along with the basic structure of nodes to define the first market."
            },
            {
                "style": "Note",
                "text": "Only one exchange assets node may exist on each exchange."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Market",
        "definition": "A market is the definition of a pair of assets (i.e.: BTC-USDT) listed as a market in the corresponding exchange.",
        "content": [
            {
                "style": "Important",
                "text": "Only markets that are effectively listed on the exchange may be configured and used with the system. Check with the exchange and make sure you understand what tickers they are using, which is the base asset and which the quoted asset on the listed markets."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a market, select <i>Add Market</i> on the exchange markets node menu. The market node is created along with the basic structure of nodes used to define the market. This option does not generate the super actions required to install and uninstall markets."
            },
            {
                "style": "Text",
                "text": "To add markets in bulk, select <i>Add Missing Markets</i> on the exchange markets node menu. This option adds all markets listed at the exchange that may result from the combination of assets listed under the exchange assets node, along with the required super actions to intall those markets."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Exchange Accounts",
        "definition": "The exchange accounts node groups the different accounts the user may have with the corresponding exchange.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add an exchange accounts node, select <i>Add Exchange Account</i> on the crypto exchange node menu. The exchange account node is created along with the basic structure of nodes used to define keys and user assets with the exchange."
            },
            {
                "style": "Note",
                "text": "Only one exchange accounts node may exist on each exchange."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "User Account",
        "definition": "A user account represents a single account with the corresponding exchange, holding the definitions of user assets, including keys and balances.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add a user account, select <i>Add User Account</i> on the exchange accounts node menu. The user account node is created along with the basic structure of nodes used to define keys and user assets with the exchange."
            },
            {
                "style": "Text",
                "text": "{% include tip.html content=\"You may add and administer as many user accounts as you wish.\" %}"
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "User Assets",
        "definition": "The user assets node groups the assets the user has at the exchange.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add user assets node, select <i>Add User Assets</i> on the user account node menu. The user assets node is created along with the first exchange account asset."
            },
            {
                "style": "Note",
                "text": "Only one user assets node may exist under a user account."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "User Keys",
        "definition": "The user keys node groups the various exchange account keys the user may have under the corresponding account with the exchange.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add user keys node, select <i>Add User Keys</i> on the user account node menu. The user keys node is created along with the first exchange account key."
            },
            {
                "style": "Note",
                "text": "Only one user keys node may exist under a user account."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Exchange Account Asset",
        "definition": "The exchange account asset represents a single asset the user has at the exchange.",
        "content": [
            {
                "style": "Text",
                "text": "The exchange account asset is a reference to an asset defined under the exchange assets node."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add an exchange account asset node, select <i>Add Asset</i> on the user assets node menu."
            },
            {
                "style": "Note",
                "text": "Remember to establish a reference with an asset defined under the exchange assets node."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Exchange Account Key",
        "definition": "The exchange account key holds the definition of the key name and secret provided by the corresponding exchange to access the user account via the exchange API.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add an exchange account key, select <i>Add Key</i> on the user keys node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure Key</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "\"codeName\": \"Paste your exchange API name or label here\","
            },
            {
                "style": "Text",
                "text": "\"secret\": \"Paste your exchange API secret key here.\""
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">codeName</code> is the name or label of your key, as supplied by the exchange.</li>"
            },
            {
                "style": "Text",
                "text": "</ul>"
            },
            {
                "style": "Warning",
                "text": "To keep your exchange keys safe, never share data structures you may download from the system, as downloads contain all information in the data structure, including personal information such as exchange keys. Use the share option on the menu instead. The share option strips sensitive information and outputs a file that is safe for sharing."
            }
        ],
        "starting": []
    },
    {
        "type": "Design Space",
        "definition": "The design space is the visual environment that hosts all system and user definitions. In practical terms, it is the black space below the slider that splits the screen horizontally, separating the design space in the bottom from the charting space on top. As a hierarchy, it features nodes that enable user-control over certain aspects of the look, feel, and behavior of the space.",
        "content": [
            {
                "style": "Text",
                "text": "Think of the design space as your desktop, or the control room of the system."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the design space node, select <i>Add Design Space</i> on the spaces node of the Superalgos Project hierarchy."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "</code\">"
            }
        ],
        "starting": []
    },
    {
        "type": "Space Style",
        "definition": "The space style node features controls over the look and feel of the space, in particular, of background colors and font sizes.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the space style node, select <i>Add Space Style</i> on the parent node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "    {"
            },
            {
                "style": "Text",
                "text": "        \"backgroundColor\": \"UI_COLOR.BLACK\","
            },
            {
                "style": "Text",
                "text": "        \"node\": {"
            },
            {
                "style": "Text",
                "text": "            \"fontSize\": 16,"
            },
            {
                "style": "Text",
                "text": "            \"imageSize\":  60,"
            },
            {
                "style": "Text",
                "text": "            \"type\": {"
            },
            {
                "style": "Text",
                "text": "                \"fontColor\": \"UI_COLOR.WHITE\""
            },
            {
                "style": "Text",
                "text": "            },"
            },
            {
                "style": "Text",
                "text": "            \"name\": {"
            },
            {
                "style": "Text",
                "text": "                \"fontColor\": \"UI_COLOR.WHITE\""
            },
            {
                "style": "Text",
                "text": "            },"
            },
            {
                "style": "Text",
                "text": "            \"menuItem\": {"
            },
            {
                "style": "Text",
                "text": "                \"backgroundColor\": \"UI_COLOR.BLACK\","
            },
            {
                "style": "Text",
                "text": "                \"fontColor\": \"UI_COLOR.WHITE\","
            },
            {
                "style": "Text",
                "text": "                \"fontSize\": 14,"
            },
            {
                "style": "Text",
                "text": "                \"imageSize\": 14"
            },
            {
                "style": "Text",
                "text": "            }"
            },
            {
                "style": "Text",
                "text": "        }"
            },
            {
                "style": "Text",
                "text": "    }"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">backgroundColor</code> refers to the background of the design space (see table below).</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">node</code> refers to all nodes in the design space.</li>"
            },
            {
                "style": "Text",
                "text": "</ul>"
            },
            {
                "style": "Text",
                "text": "  * <code class=\"language-none\">imageSize</code> refers to the size of icons representing nodes."
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">type</code> refers to the type of node, as indicated by the string of text below each node.</li>"
            },
            {
                "style": "Text",
                "text": "</ul>"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">name</code> refers to the name or label of the node, as indicated above the node.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">menuItem</code> refers to items on the right-hand side of the menu.</li>"
            },
            {
                "style": "Text",
                "text": "</ul>"
            },
            {
                "style": "Text",
                "text": "  * <code class=\"language-none\">fontSize</code> refers to the size of the font of the string of text."
            },
            {
                "style": "Text",
                "text": "  * <code class=\"language-none\">imageSize</code> refers to the size of the icon illustrating the menu item."
            },
            {
                "style": "Text",
                "text": "<table class=\"docs-table\"><tr><td> Variable Value </td><td> RGB Value </td><td> Color Sample </td></tr>"
            },
            {
                "style": "Text",
                "text": "<tr><td> :--- </td><td> :---: </td><td> :------------------- </td></tr>"
            },
            {
                "style": "Text",
                "text": "<tr><td> <code class=\"language-none\">DARK</code> </td><td> 48, 48, 54 </td><td> <span style=\"display: block; background: RGB(48, 48, 54); border: 1px solid black;\">&nbsp;</span> </td></tr>"
            },
            {
                "style": "Text",
                "text": "<tr><td> <code class=\"language-none\">LIGHT</code> </td><td> 234, 226, 222 </td><td> <span style=\"display: block; background: RGB(234, 226, 222); border: 1px black; border: 1px solid black;\">&nbsp;</span> </td></tr>"
            },
            {
                "style": "Text",
                "text": "<tr><td> <code class=\"language-none\">GREY</code> </td><td> 150, 150, 150 </td><td> <span style=\"display: block; background: RGB(150, 150, 150); border: 1px solid black;\">&nbsp;</span> </td></tr>"
            },
            {
                "style": "Text",
                "text": "<tr><td> <code class=\"language-none\">LIGHT_GREY</code> </td><td> 247, 247, 247 </td><td> <span style=\"display: block; background: RGB(247, 247, 247); border: 1px solid black;\">&nbsp;</span> </td></tr>"
            },
            {
                "style": "Text",
                "text": "<tr><td> <code class=\"language-none\">WHITE</code> </td><td> 255, 255, 255 </td><td> <span style=\"display: block; background: RGB(255, 255, 255); border: 1px solid black;\">&nbsp;</span> </td></tr>"
            },
            {
                "style": "Text",
                "text": "<tr><td> <code class=\"language-none\">BLACK</code> </td><td> 0, 0, 0 </td><td> <span style=\"display: block; background: RGB(0, 0, 0); border: 1px solid black;\">&nbsp;</span> </td></tr>"
            },
            {
                "style": "Text",
                "text": "<tr><td> <code class=\"language-none\">GOLDEN_ORANGE</code> </td><td> 240, 162, 2 </td><td> <span style=\"display: block; background: RGB(240, 162, 2); border: 1px solid black;\">&nbsp;</span> </td></tr>"
            },
            {
                "style": "Text",
                "text": "<tr><td> <code class=\"language-none\">RUSTED_RED</code> </td><td> 204, 88, 53 </td><td> <span style=\"display: block; background: RGB(204, 88, 53); border: 1px solid black;\">&nbsp;</span> </td></tr>"
            },
            {
                "style": "Text",
                "text": "<tr><td> <code class=\"language-none\">GREEN</code> </td><td> 188, 214, 67 </td><td> <span style=\"display: block; background: RGB(188, 214, 67); border: 1px solid black;\">&nbsp;</span> </td></tr>"
            },
            {
                "style": "Text",
                "text": "<tr><td> <code class=\"language-none\">RED</code> </td><td> 223, 70, 60 </td><td> <span style=\"display: block; background: RGB(223, 70, 60); border: 1px solid black;\">&nbsp;</span> </td></tr>"
            },
            {
                "style": "Text",
                "text": "<tr><td> <code class=\"language-none\">PATINATED_TURQUOISE</code> </td><td> 27, 153, 139 </td><td> <span style=\"display: block; background: RGB(27, 153, 139); border: 1px solid black;\">&nbsp;</span> </td></tr>"
            },
            {
                "style": "Text",
                "text": "<tr><td> <code class=\"language-none\">TITANIUM_YELLOW</code> </td><td> 244, 228, 9 </td><td> <span style=\"display: block; background: RGB(244, 228, 9); border: 1px solid black;\">&nbsp;</span> </td></tr>"
            },
            {
                "style": "Text",
                "text": "<tr><td> <code class=\"language-none\">MANGANESE_PURPLE</code> </td><td> 91,80, 122 </td><td> <span style=\"display: block; background: RGB(91,80, 122); border: 1px solid black;\">&nbsp;</span> </td></tr>"
            },
            {
                "style": "Text",
                "text": "<tr><td> <code class=\"language-none\">TURQUOISE</code> </td><td> 74, 207, 217 </td><td> <span style=\"display: block; background: RGB(74, 207, 217); border: 1px solid black;\">&nbsp;</span> </td></tr>"
            },
            {
                "style": "Text",
                "text": "<tr><td> <code class=\"language-none\">DARK_TURQUOISE</code> </td><td> 2, 149, 170 </td><td> <span style=\"display: block; background: RGB(2, 149, 170); border: 1px solid black;\">&nbsp;</span> </td></tr>"
            },
            {
                "style": "Text",
                "text": "</table>."
            }
        ],
        "starting": []
    },
    {
        "type": "Space Settings",
        "definition": "The space settings node features controls over the phisics, proportions, and positioning of icons representing node, and their menus.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the space settings node, select <i>Add Space Settings</i> on the parent node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "    \"node\": {"
            },
            {
                "style": "Text",
                "text": "        \"distancePercentage\": 60,"
            },
            {
                "style": "Text",
                "text": "        \"radiusPercentage\": 85,"
            },
            {
                "style": "Text",
                "text": "        \"massPercentage\": 100,"
            },
            {
                "style": "Text",
                "text": "        \"menuItem\": {"
            },
            {
                "style": "Text",
                "text": "            \"widthPercentage\": 100,"
            },
            {
                "style": "Text",
                "text": "            \"heightPercentage\": 60,"
            },
            {
                "style": "Text",
                "text": "            \"radiusPercentage\": 90"
            },
            {
                "style": "Text",
                "text": "        }"
            },
            {
                "style": "Text",
                "text": "    },"
            },
            {
                "style": "Text",
                "text": "    \"physics\": false"
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">node</code> refers to every node in the design space.</li>"
            },
            {
                "style": "Text",
                "text": "</ul>"
            },
            {
                "style": "Text",
                "text": "  * <code class=\"language-none\">radiusPercentage</code> is the radius of the circular nodes' menu applied as a percentage of an arbitrary default radius."
            },
            {
                "style": "Text",
                "text": "  * <code class=\"language-none\">massPercentage</code> is the refernce mass of nodes that affect the attraction and repulsion of the environment's pysics whe the physics setting is set to <code class=\"language-none\">true</code>."
            },
            {
                "style": "Text",
                "text": "  * <code class=\"language-none\">menuItem</code> refers to the items on the right-hand side of nodes' menus."
            },
            {
                "style": "Text",
                "text": "    * <code class=\"language-none\">widthPercentage</code> is the reference width of an item applied as a percentage of an arbitrary default width."
            },
            {
                "style": "Text",
                "text": "    * <code class=\"language-none\">heightPercentage</code> is the reference height of an item applied as a percentage of an arbitrary default height."
            },
            {
                "style": "Text",
                "text": "    * <code class=\"language-none\">radiusPercentage</code> is the reference radious of the circular matrix that governs the distribution of items in the circular menu. Larger numbers cause items to spread appart while smaller numbers makes items lie closer to each other."
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">physics</code> determines wether the environment is static (<code class=\"language-none\">false<code class=\"language-none\">) or dynamic (</code>true</code>). When physics is set to <code class=\"language-none\">true</code>, nodes in the design space are affected by th gravitational pull and repulsion of other nodes.</li></ul>"
            }
        ],
        "starting": []
    },
    {
        "type": "Charting Space",
        "definition": "The charting space is the hierarchy that governs the configuration of the charts, and the bidimensional space on which charts are drawn.",
        "content": [
            {
                "style": "Text",
                "text": "Think of the charting space as a huge drawing board. You may have lots of information plotted on different parts of the space and use a viewport to look into that space."
            },
            {
                "style": "Text",
                "text": "There is only one charting space hierarchy, thus all charts are configured here. As is common throughout the system, different concepts and elements of the charts such as scales, data layers and so on, are represented by nodes in the hierarchy. The system allows great flexibility on how to visualize information over the charts by adding, configuring, and arranging these nodes."
            }
        ],
        "adding": [],
        "configuring": [],
        "charts": []
    },
    {
        "type": "Project Dashboards"
    },
    {
        "type": "Dashboard",
        "definition": "A dashboard is a collection of time machines, each containing any number of charts.",
        "content": [
            {
                "style": "Text",
                "text": "The concept of the dashboard allows having multiple charts configured all at once, so that you may consult different exchanges, different markets, different time frames, or different technical studies on demand, simply by moving around and zooming in or out. You may put charts side by side, or even superimpose them to study market flows, search for arbitrage opportunities, or simply keep them in sight when you analyze particular market situations."
            },
            {
                "style": "Text",
                "text": "At the moment, the functionality of a dashboard is trivial: grouping time machines. However, in the future, it will offer various features to enhance the user experience."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a dashboard, select <i>Add Dashboard</i> on the Charting Space node menu."
            }
        ],
        "configuring": [],
        "charts": []
    },
    {
        "type": "Time Machine",
        "definition": "A time machine synchronizes multiple timeline charts over the same timeline. Timeline charts within a time machine may have different rate scales or time frame scales, but their time scale will always match.",
        "content": [
            {
                "style": "Text",
                "text": "Think of a time machine as an aide that helps you keep any number of pieces of information synchronized on the same time scale. Every data structure that you set up within the same time machine, will always be synchronized in time. Put in other words, the open and closing datetime of each dataset will always be aligned on the vertical axis."
            },
            {
                "style": "Text",
                "text": "On the other hand, when you arrange charts on different time machines, they are completely independent of one another."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a time machine, select <i>Add Time Machine</i> on the Dashboard node menu."
            }
        ],
        "configuring": [],
        "charts": []
    },
    {
        "type": "Viewport",
        "definition": "The viewport is a window through which you may look into the charting space.",
        "content": [
            {
                "style": "Text",
                "text": "The viewport offers an opening into the visual environment in which you may see, analyze and go over every piece of data involved in the process of trading cryptocurrencies:"
            },
            {
                "style": "Text",
                "text": "<ul><li>Live and historic market data;</li>"
            },
            {
                "style": "Text",
                "text": "<li>Data crunched in the form of indicators;</li>"
            },
            {
                "style": "Text",
                "text": "<li>The specific effects of the rules you will program into your strategies, and how strategies behave during testing and live trading sessions.</li>"
            },
            {
                "style": "Text",
                "text": "</ul>"
            },
            {
                "style": "Note",
                "text": "The information that is out of focus, that is, out of the viewport, is not read nor rendered graphically, thus, does not consume resources."
            }
        ],
        "adding": [],
        "configuring": [],
        "charts": []
    },
    {
        "type": "Time Scale",
        "definition": "The time scale controls the scale of the horizontal axis, that is, the timeline of the corresponding time machine, and of all of the timeline charts within it.",
        "content": [
            {
                "style": "Text",
                "text": "{% if include.heading == \"more\" %}##{% else %}{{include.heading}}{% endif %}### Scale Minimum and Maximum Values"
            },
            {
                "style": "Text",
                "text": "A time scale has a minimum and a maximum value. The minimum value is the value at the left border of the chart. The maximum, is the value at the right border of the chart."
            },
            {
                "style": "Text",
                "text": "In technical terms, the minimum and maximum scale values are constantly changing as, whenever you pan across the charts, you are directly affecting the minimum and maximum scale values. That said, the actual scale doesn't change when panning across a chart."
            },
            {
                "style": "Text",
                "text": "{% if include.heading == \"more\" %}##{% else %}{{include.heading}}{% endif %}### Automatic Scale"
            },
            {
                "style": "Text",
                "text": "The system features an automatic adjustment of the scale, which is turned on by default in our shared workspaces. The scale may be automatic in its minimum value, in its maximum value, or both."
            },
            {
                "style": "Text",
                "text": "When the scale is automatic in the minimum value, the scale is adjusted so that the chart shows all data from the beginning of the market. Panning the charts under such setting has the effect of compressing and decompressing the data against the left border of the chart."
            },
            {
                "style": "Text",
                "text": "When the scale is automatic in the maximum value, the scale is adjusted so that the chart shows all data until the end of the market. In such case, panning the charts has the effect of compressing and decompressing the data against the right border of the chart."
            },
            {
                "style": "Text",
                "text": "When the scale is automatic in both the minimum and maximum value, the scale is adjusted so that the chart shows the whole market. In such case, when you click and drag to pan the charts, the settings turns back to manual on both ends of the chart."
            },
            {
                "style": "Note",
                "text": "Having the time scale set to automatic by default helps finding the data as soon as it starts being processed the first time you run the Masters bot instances."
            },
            {
                "style": "Text",
                "text": "{% if include.heading == \"more\" %}##{% else %}{{include.heading}}{% endif %}### Manual Scale"
            },
            {
                "style": "Text",
                "text": "The scale features a manual mode. When in manual mode the scale does not change, even if the minimum and maximum values change while panning through a chart. This is the natural state of the time scale."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a time scale, select <i>Add Time Scale</i> on the time machine node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure Rate Scale</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "    \"fromDate\": \"2019-05-02T20:07:50.872Z\","
            },
            {
                "style": "Text",
                "text": "    \"toDate\": \"2019-05-22T20:28:21.515Z\","
            },
            {
                "style": "Text",
                "text": "    \"autoMinScale\": false,"
            },
            {
                "style": "Text",
                "text": "    \"autoMaxScale\": false"
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">minValue</code> is a date in the Epoch time format that represents the value of the scale at the left border of the chart.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">maxValue</code> is a date in the Epoch time format that represents the value of the scale at the right border of the chart.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">autoMinScale</code> sets the mode of the scale for the minimum value; <code class=\"language-none\">true<code class=\"language-none\"> sets the value to automatic, </code>false</code> sets the value to manual.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">autoMaxScale</code> sets the mode of the scale for the maximum value; <code class=\"language-none\">true<code class=\"language-none\"> sets the value to automatic, </code>false</code> sets the value to manual.</li>"
            },
            {
                "style": "Note",
                "text": "</ul>"
            }
        ],
        "charts": [
            {
                "style": "Text",
                "text": "<H4>Automatic Scale</H4>"
            },
            {
                "style": "Text",
                "text": "<b>1. To change the automatic scale settings</b>, place the mouse pointer over the corresponding time box, press the <kbd>Shift</kbd> key and slowly scroll the wheel of the mouse. The action cycles through different possible scale automation settings. Notice a tiny green triangle to the sides of the time scale icon."
            },
            {
                "style": "Text",
                "text": "<ul><li>A triangle pointing right means that the maximum value of the scale is automatic.</li>"
            },
            {
                "style": "Text",
                "text": "<li>A triangle pointing left means that the minimum value of the scale is automatic.</li>"
            },
            {
                "style": "Text",
                "text": "<li>Both triangles present at the same time means that both minimum and maximum values are automatic.</li>"
            },
            {
                "style": "Text",
                "text": "<li>No triangle means that both minimum and maximum values are in manual mode.</li>"
            },
            {
                "style": "Text",
                "text": "</ul>"
            },
            {
                "style": "Text",
                "text": "<H4>Manual Scale</H4>"
            },
            {
                "style": "Text",
                "text": "<b>2. To adjust the scale</b>, make sure either or both minimum and maximum values are in manual mode. Place the mouse pointer over the time box and scroll the wheel of the mouse. The scale will increase or decrease accordingly, depending on which values are set to manual."
            },
            {
                "style": "Text",
                "text": "{% include image.html file='interface/time-scale-01.gif' url='yes' max-width='100' caption='When the scale is set to manual, scrolling the mouse wheel on top of the time scale box changes the scale.' %}"
            },
            {
                "style": "Text",
                "text": "Notice that, while changing the scale, a number is displayed replacing the actual datetime. This is a reference value of the scale, that may serve for comparison purposes, with scales in other charts."
            },
            {
                "style": "Note",
                "text": "This action has no effect when both minimum and maximum values are set to automatic mode."
            }
        ]
    },
    {
        "type": "Rate Scale",
        "definition": "The rate scale controls the scale of the vertical axis, that is, the scale of the quoted asset, either of the time machine or of the timeline chart, depending on where the node is located.",
        "content": [
            {
                "style": "Text",
                "text": "Rate scales may exist both at the level of a time machine and at the level of a timeline chart, each affecting the corresponding concept."
            },
            {
                "style": "Text",
                "text": "When set at the level of the time machine, the scale settings affect all charts within the time machine. When set at the level of the timeline chart, the settings override the rate scale at the time machine level. This allows having multiple charts on the same time machine, each with a different rate scale."
            },
            {
                "style": "Text",
                "text": "{% if include.heading == \"more\" %}##{% else %}{{include.heading}}{% endif %}### Scale Minimum and Maximum Values"
            },
            {
                "style": "Text",
                "text": "A rate scale has a minimum and a maximum value. The minimum value is the value at bottom of the chart. The maximum, is the value at the top of the chart."
            },
            {
                "style": "Text",
                "text": "In technical terms, the minimum and maximum scale values are constantly changing as, whenever you pan across the charts, you are directly affecting the minimum and maximum scale values. That said, the actual scale may change dynamically or not, depending on the scale-automation settings."
            },
            {
                "style": "Text",
                "text": "{% if include.heading == \"more\" %}##{% else %}{{include.heading}}{% endif %}### Automatic Scale"
            },
            {
                "style": "Text",
                "text": "The system features an automatic adjustment of the scale, which is turned on by default in our shared workspaces. The scale may be automatic in its minimum value, in its maximum value, or both."
            },
            {
                "style": "Text",
                "text": "When the scale is automatic in the minimum value, the scale is adjusted so that no piece of information in the span of the chart ever remains below the bottom of the chart. As a result, the lowest data point aligns with the bottom of the chart."
            },
            {
                "style": "Text",
                "text": "When the scale is automatic in the maximum value, the scale is adjusted so that no piece of information in the span of the chart ever remains above the top of the chart. As a result, the highest data point aligns with the top of the chart."
            },
            {
                "style": "Text",
                "text": "The scale may be automated on either, or both minimum and maximum values at the same time. In the later case, no data point in the span of the chart ever remains out of the visible area of the chart, as the lowest data point aligns with the bottom of the chart and the highest aligns with the top."
            },
            {
                "style": "Text",
                "text": "{% if include.heading == \"more\" %}##{% else %}{{include.heading}}{% endif %}### Manual Scale"
            },
            {
                "style": "Text",
                "text": "The system also features a manual mode. When in manual mode the scale does not change, even if the minimum and maximum values change while panning across a chart. This design feature allows comparing different periods using the same scale, which may be valuable in many cases."
            },
            {
                "style": "Text",
                "text": "{% if include.heading == \"more\" %}##{% else %}{{include.heading}}{% endif %}### Scale Offset"
            },
            {
                "style": "Text",
                "text": "The offset is a feature of the rate scale by which the scale may be shifted upwards or downwards. As a result, charts aligned on the vertical axis&mdash;synchronized in datetime by a shared time machine&mdash;may be put one above the other. In technical terms, what happens is that the scale is shifted upwards or downwards."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a rate scale, select <i>Add Rate Scale</i> on the time machine or the timeline chart node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure Rate Scale</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "    \"minValue\": 388.60416666666424,"
            },
            {
                "style": "Text",
                "text": "    \"maxValue\": 9715.104166666664,"
            },
            {
                "style": "Text",
                "text": "    \"autoMinScale\": true,"
            },
            {
                "style": "Text",
                "text": "    \"autoMaxScale\": true"
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">minValue</code> is a numerical value that represents the value of the scale at the bottom of the chart.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">maxValue</code> is a numerical value that represents the value of the scale at the top of the chart.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">autoMinScale</code> sets the mode of the scale for the minimum value; <code class=\"language-none\">true<code class=\"language-none\"> sets the value to automatic, </code>false</code> sets the value to manual.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">autoMaxScale</code> sets the mode of the scale for the maximum value; <code class=\"language-none\">true<code class=\"language-none\"> sets the value to automatic, </code>false</code> sets the value to manual.</li>"
            },
            {
                "style": "Note",
                "text": "</ul>"
            }
        ],
        "charts": [
            {
                "style": "Text",
                "text": "<H4>Automatic Scale</H4>"
            },
            {
                "style": "Text",
                "text": "<b>1. To change the automatic scale settings</b>, place the mouse pointer over the corresponding time machine or timeline chart rate box, press the <kbd>Shift</kbd> key and slowly scroll the wheel of the mouse. The action cycles through different possible scale automation settings. Notice a tiny green triangle below and/or above the rate scale icon."
            },
            {
                "style": "Text",
                "text": "<ul><li>A triangle pointing up means that the maximum value of the scale is automatic.</li>"
            },
            {
                "style": "Text",
                "text": "<li>A triangle pointing down means that the minimum value of the scale is automatic.</li>"
            },
            {
                "style": "Text",
                "text": "<li>Both triangles present at the same time means that both minimum and maximum values are automatic.</li>"
            },
            {
                "style": "Text",
                "text": "<li>No triangle means that both minimum and maximum values are in manual mode.</li>"
            },
            {
                "style": "Text",
                "text": "</ul>"
            },
            {
                "style": "Text",
                "text": "<H4>Manual Scale</H4>"
            },
            {
                "style": "Text",
                "text": "<b>2. To adjust the scale</b>, make sure either or both minimum and maximum values are in manual mode. Place the mouse pointer over the corresponding time machine or timeline chart rate box and scroll the wheel of the mouse. The scale will increase or decrease accordingly, depending on which values are set to manual."
            },
            {
                "style": "Text",
                "text": "{% include image.html file='interface/rate-scale-01.gif' url='yes' max-width='100' caption='When the scale is set to manual, scrolling the mouse wheel on top of the rate scale box changes the scale.' %}"
            },
            {
                "style": "Text",
                "text": "Notice that, while changing the scale, a number is displayed replacing the actual rate. This is a reference value of the scale, that may serve for comparison purposes, with scales in other charts."
            },
            {
                "style": "Note",
                "text": "This action has no effect when both minimum and maximum values are set to automatic mode."
            },
            {
                "style": "Text",
                "text": "<H4>Scale Offset</H4>"
            },
            {
                "style": "Text",
                "text": "<b>3. To shift or offset a timeline chart on the vertical axis</b>, place the mouse pointer on the rate box, left-click and drag upwards or downwards, as desired. The timeline chart will shift in the specified direction while the remaining charts stay in the same position."
            },
            {
                "style": "Text",
                "text": "{% include image.html file='interface/rate-scale-02.gif' url='yes' max-width='100' caption='To control the offset between timeline charts, right-click on the rate box and drag upwards or downwards.' %}"
            },
            {
                "style": "Note",
                "text": "Setting an offset in a timeline chart only makes sense in the context of a time machine with multiple charts. That is, if you are browsing a single chart, an offset behaves the same as moving the single chart up or down."
            }
        ]
    },
    {
        "type": "Time Frame Scale",
        "definition": "The time frame scale controls the time frame setting, that is, the period represented by each candle, either of the time machine or of the timeline chart, depending on where the node is located.",
        "content": [
            {
                "style": "Text",
                "text": "When the time frame scale is set at the level of the time machine, the scale setting affects all charts within the time machine. When set at the level of the timeline chart, the setting overrides the time frame scale at the time machine level. This allows comparing charts in different time frames, but still synchronized at the datetime level."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a time frame scale, select <i>Add Time Frame Scale</i> on the time machine or the timeline chart node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure Frame Scale</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "    \"value\":\"06-hs\""
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">value</code> can be any of the time frames supported by the system:</li>"
            },
            {
                "style": "Text",
                "text": "</ul>"
            },
            {
                "style": "Text",
                "text": "  * <code class=\"language-none\">01-hs</code>, <code class=\"language-none\">02-hs<code class=\"language-none\">, </code>03-hs</code>, <code class=\"language-none\">04-hs</code>, <code class=\"language-none\">06-hs<code class=\"language-none\">, </code>08-hs</code>, <code class=\"language-none\">12-hs</code>, and <code class=\"language-none\">24-hs</code>."
            },
            {
                "style": "Note",
                "text": "  The values entered via the design space and the charts are synchronized and stored in the node."
            }
        ],
        "charts": [
            {
                "style": "Text",
                "text": "<b>1. To set a time frame value</b>, place the mouse pointer over the corresponding time machine or timeline chart time frame box and scroll the mouse wheel."
            },
            {
                "style": "Text",
                "text": "{% include image.html file='interface/time-frame-scale-00.gif' url='yes' max-width='100' caption='To set a time frame, scroll the wheel of the mouse over the time frame scale box.' %}"
            }
        ]
    },
    {
        "type": "Timeline Chart",
        "definition": "The timeline chart represents a chart within a time machine, which may have independent rate and time frame scales, as well as particular layers.",
        "content": [
            {
                "style": "Text",
                "text": "In other words, a timeline chart&mdash;often referred simply as <i>chart</i>&mdash;is a set of information to be displayed over a timeline. The information may include candles&mdash;the main and foremost resource&mdash;as well as any other indicator, study or&mdash;in general&mdash;data products that may be available."
            },
            {
                "style": "Text",
                "text": "You may add as many charts as you wish. Charts within the same time machine are synchronized in the y-axis, that is, in the datetime dimension. Charts in different time machines are independent of each other concerning the datetime. In either case, you may also add rate scales and time frame scales at the timeline charts level."
            },
            {
                "style": "Text",
                "text": "The information that each timeline chart makes available on the screen is given by the layers set up in the corresponding layers manager."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a timeline chart, select <i>Add Timeline Chart</i> on the preferred time machine node menu."
            }
        ],
        "configuring": [],
        "charts": []
    },
    {
        "type": "Layer Manager",
        "definition": "The layer manager determines which layers will be visible on the corresponding timeline chart.",
        "content": [
            {
                "style": "Text",
                "text": "In other words, you use the layers manager node to configure which data products you wish to be made available for visualization purposes on the charts, in particular, on a specific timeline chart to which the layers manager node is attached to."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a layers manager, select <i>Add Layers Manager</i> on the preferred timeline chart node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure Layers Manager</i> in the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "    \"visibleLayers\": 3,"
            },
            {
                "style": "Text",
                "text": "    \"panelLocation\": {"
            },
            {
                "style": "Text",
                "text": "        \"upOrDown\": \"up\","
            },
            {
                "style": "Text",
                "text": "        \"leftOrRight\": \"left\""
            },
            {
                "style": "Text",
                "text": "    },"
            },
            {
                "style": "Text",
                "text": "    \"label2FontSize\": 12"
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">visibleLayers</code> keeps track of how many layers the managers is rolled to, that is, how many layers it is displaying.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">panelLocation</code> keeps track of the position of the panel relative to the four screen corners.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">label2FontSize</code> allows adjusting the font size of the second-order label of each layer, displaying the name of the exchange and market.</li></ul>"
            }
        ],
        "charts": []
    },
    {
        "type": "Layer",
        "definition": "A layer represents a reference to a data product in the data storage node of the network hierarchy. Conceptually, it means that a certain data product, which exists in a certain location on the network, holds the data to be rendered on the charts.",
        "content": [
            {
                "style": "Text",
                "text": "To set up a layer, you need to establish a reference with the data product of your choice."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a layer, select <i>Add Layer</i> on the layer manager node menu."
            },
            {
                "style": "Note",
                "text": "After adding a layer node, make sure you establish a reference to the corresponding data product in the data storage node of the network hierarchy."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure Layer</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "    \"status\":\"on\","
            },
            {
                "style": "Text",
                "text": "    \"showPanels\":true"
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "<i> <code class=\"language-none\">status</code> may be </i>on<i> or </i>off* and refers to the layer being visible or not on the charts."
            },
            {
                "style": "Text",
                "text": "<i> <code class=\"language-none\">showPanels</code> may be </i>true<i> or </i>false<i>; </i>true<i> shows the plotter panel that may be associated with the data product as per the plotter module definitions; </i>false* makes panels invisible."
            }
        ],
        "charts": [
            {
                "style": "Text",
                "text": "To turn layers on and off, simply click on the layer in the corresponding products panel."
            },
            {
                "style": "Text",
                "text": "To turn on and off a layer panel, click the panel button on the bottom-left corner of the layer."
            }
        ]
    },
    {
        "type": "Layer Panels"
    },
    {
        "type": "Layer Panel"
    },
    {
        "type": "Layer Polygons"
    },
    {
        "type": "Layer Polygon"
    },
    {
        "type": "Bot Layers"
    },
    {
        "type": "Layer Folder"
    },
    {
        "type": "Data Storage",
        "definition": "The data storage node holds the definitions as to what data is stored in the corresponding network node.",
        "content": [
            {
                "style": "Text",
                "text": "Bot instances running on the data mining and trading sections of a network node produce data products that need to be stored somewhere, specifically. The data storage node and its chain of offspring determine which data is to be stored where; that is, in what network node."
            },
            {
                "style": "Text",
                "text": "Like with the data mining section and the sections referring to trading operations (testing and production environments), the data storage section is too organized by exchange, market, and data or trading mines. See the sorting of tasks page for the details."
            },
            {
                "style": "Text",
                "text": "The storage of data is split between data mines data and "
            },
            {
                "style": "Text",
                "text": "The data stored on each node of the network may be accessed by others, including the charting system, to visualize information via plotters defined in data mines, by trading systems to make trading decisions, and even by third-party systems. The information regarding trading mine data is explained in length in the trading engine section of the documentation."
            },
            {
                "style": "Text",
                "text": "The setup of data storage definitions is done automatically when the install market function under the exchange markets node of the Crypto Ecosystem hierarchy is used. However, when data mining or trading tasks are created manually, the data storage definitions must be created manually as well, using the tools available in each of the data structures below this node."
            },
            {
                "style": "Text",
                "text": "{% include node-deletion-warning.html %}"
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a data storage, select <i>Add Data Storage</i> on the network node menu."
            },
            {
                "style": "Note",
                "text": "Only one data storage node may exist on each network node."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Data Mine Tasks",
        "definition": "The data mine tasks node is an organizational device that groups tasks corresponding to the referenced data mine.",
        "content": [
            {
                "style": "Text",
                "text": "The data mine tasks node must reference the definition of a data mine. The node may spawn tasks for each bot in the data mine."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a data mine tasks node, select <i>Add Data Mine Tasks</i> on the parent node menu. This action adds the node but does not establish a reference with any data mine."
            },
            {
                "style": "Text",
                "text": "The smarter use of the node involves using the <i>Add Missing Data Mine Tasks</i> option on the parent node menu. This action creates a data mine tasks node for each data mine in the workspace, establishing a reference with the corresponding data mines. This is the first step in the direction of quickly setting up tasks for each bot in a given data mine."
            },
            {
                "style": "Note",
                "text": "See the task node definition and the <i>Adding a Task Node</i> section for all the details."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "</code\">"
            }
        ],
        "starting": [
            {
                "style": "Text",
                "text": "Select <i>Run All Task Managers</i> or <i>Stop All Task Managers</i> on the menu to start and stop all tasks under this node."
            }
        ]
    },
    {
        "type": "Trading Mine Tasks",
        "definition": "The trading mine tasks node is an organizational device that groups tasks corresponding to the referenced trading mine.",
        "content": [
            {
                "style": "Text",
                "text": "The market trading tasks node must reference the definition of a data mine. The node may spawn tasks for each bot in the data mine."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a trading mine tasks node, select <i>Add Trading Mine Tasks</i> on the parent node menu. This action adds the node but does not establish a reference with any data mine."
            },
            {
                "style": "Text",
                "text": "The smarter use of the node involves using the <i>Add Missing market trading tasks</i> option on the parent node menu. This action creates a market trading tasks node for each data mine in the workspace, establishing a reference with the corresponding data mines. This is the first step in the direction of quickly setting up tasks for each bot in a given data mine."
            },
            {
                "style": "Note",
                "text": "See the task node definition and the <i>Adding a Task Node</i> section for all the details."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "</code\">"
            }
        ],
        "starting": [
            {
                "style": "Text",
                "text": "Select <i>Run All Task Managers</i> or <i>Stop All Task Managers</i> on the menu to start and stop all tasks under this node."
            }
        ]
    },
    {
        "type": "Learning Mine Tasks"
    },
    {
        "type": "Market Data Tasks",
        "definition": "A market data tasks node groups data mining tasks operating in a specific market.",
        "content": [
            {
                "style": "Text",
                "text": "The market data tasks node must reference a market defined in the Crypto Ecosystem hierarchy."
            },
            {
                "style": "Text",
                "text": "This node may spawn individual data products or may deploy data products in bulk organized by data mine and by bots. See the data products node for the details."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a market data tasks node, select <i>Add Market Data</i> on the parent node menu."
            },
            {
                "style": "Note",
                "text": "Remember to establish a reference with a market defined in the Crypto Ecosystem hierarchy after adding the node."
            },
            {
                "style": "Text",
                "text": "You may also add market data tasks nodes in bulk for all markets that may have been previously defined in the Crypto Ecosystem hierarchy. To do that, select <i>Add Missing Markets</i> on the parent node menu. A market data tasks node is created for each defined market, each with the corresponding reference."
            }
        ],
        "configuring": [],
        "starting": [
            {
                "style": "Text",
                "text": "Select <i>Run All Data Mine Tasks</i> or <i>Stop All Data Mine Tasks</i> on the menu to start and stop all tasks under this node."
            }
        ]
    },
    {
        "type": "Market Trading Tasks",
        "definition": "A market trading tasks node groups trading tasks operating in a specific market.",
        "content": [
            {
                "style": "Text",
                "text": "The market trading tasks node must reference a market defined in the Crypto Ecosystem hierarchy."
            },
            {
                "style": "Text",
                "text": "This node may spawn individual data products or may deploy data products in bulk organized by data mine and by bots. See the data products node for the details."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a market trading tasks node, select <i>Add Market Data</i> on the parent node menu."
            },
            {
                "style": "Note",
                "text": "Remember to establish a reference with a market defined in the Crypto Ecosystem hierarchy after adding the node."
            },
            {
                "style": "Text",
                "text": "You may also add market trading tasks nodes in bulk for all markets that may have been previously defined in the Crypto Ecosystem hierarchy. To do that, select <i>Add Missing Markets</i> on the parent node menu. A market trading tasks node is created for each defined market, each with the corresponding reference."
            }
        ],
        "configuring": [],
        "starting": [
            {
                "style": "Text",
                "text": "Select <i>Run All Trading Mine Tasks</i> or <i>Stop All Trading Mine Tasks</i> on the menu to start and stop all tasks under this node."
            }
        ]
    },
    {
        "type": "Market Learning Tasks"
    },
    {
        "type": "Exchange Data Tasks",
        "definition": "The exchange data tasks node organizes data mining tasks by exchange. That is, each exchange installed in the system has an exchange data tasks node grouping all market data tasks corresponding to the said exchange.",
        "content": [
            {
                "style": "Text",
                "text": "The exchange data tasks node must reference the exchange of choice. This reference constraints the rest of the definitions to the context of the said exchange."
            },
            {
                "style": "Text",
                "text": "When representing an exchange featured in the system's icons library, the standard exchange data tasks icon is replaced by the exchange's logo."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a specific exchange data tasks node, select <i>Add Exchange Data Tasks</i> on the parent node menu."
            },
            {
                "style": "Note",
                "text": "Remember to establish a reference to the desired exchange in the Crypto Ecosystem hierarchy."
            },
            {
                "style": "Text",
                "text": "You may also add exchange data tasks node in bulk for all exchanges that may have been previously defined in the Crypto Ecosystem hierarchy. To do that, select <i>Add Missing Exchanges</i> on the parent node menu. An exchange data tasks node is created for each defined exchange, each with the corresponding reference."
            }
        ],
        "configuring": [],
        "starting": [
            {
                "style": "Text",
                "text": "Select <i>Run All Market Data Tasks</i> or <i>Stop All Market Data Tasks</i> on the menu to start and stop all tasks under this node."
            }
        ]
    },
    {
        "type": "Exchange Trading Tasks",
        "definition": "The exchange trading tasks node organizes trading tasks by exchange. That is, each exchange installed in the system has an exchange trading tasks node grouping all market trading tasks corresponding to the said exchange.",
        "content": [
            {
                "style": "Text",
                "text": "The exchange trading tasks node must reference the exchange of choice. This reference constraints the rest of the definitions to the context of the said exchange."
            },
            {
                "style": "Text",
                "text": "When representing an exchange featured in the system's icons library, the standard exchange trading tasks icon is replaced by the exchange's logo."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a specific exchange trading tasks node, select <i>Add Exchange Trading Tasks</i> on the parent node menu."
            },
            {
                "style": "Note",
                "text": "Remember to establish a reference to the desired exchange in the Crypto Ecosystem hierarchy."
            },
            {
                "style": "Text",
                "text": "You may also add exchange trading tasks node in bulk for all exchanges that may have been previously defined in the Crypto Ecosystem hierarchy. To do that, select <i>Add Missing Exchanges</i> on the parent node menu. An exchange trading tasks node is created for each defined exchange, each with the corresponding reference."
            }
        ],
        "configuring": [],
        "starting": [
            {
                "style": "Text",
                "text": "Select <i>Run All Market Trading Tasks</i> or <i>Stop All Market Trading Tasks</i> on the menu to start and stop all tasks under this node."
            }
        ]
    },
    {
        "type": "Exchange Learning Tasks"
    },
    {
        "type": "Project Data Tasks"
    },
    {
        "type": "Data Tasks"
    },
    {
        "type": "Project Learning Tasks"
    },
    {
        "type": "Learning Tasks"
    },
    {
        "type": "Project Trading Tasks"
    },
    {
        "type": "Testing Trading Tasks"
    },
    {
        "type": "Production Trading Tasks"
    },
    {
        "type": "Exchange Data Products",
        "definition": "The exchange data products node organizes data mines data by exchange. That is, each exchange installed in the system has an exchange data products node grouping all market data products nodes corresponding to the said exchange.",
        "content": [
            {
                "style": "Text",
                "text": "The exchange data products node must reference the exchange of choice. This reference constraints the rest of the definitions to the context of the said exchange."
            },
            {
                "style": "Text",
                "text": "When representing an exchange featured in the system's icons library, the standard exchange data tasks icon is replaced by the exchange's logo."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a specific exchange data products node, select <i>Add Exchange Data Products</i> on the parent node menu."
            },
            {
                "style": "Note",
                "text": "Remember to establish a reference to the desired exchange in the Crypto Ecosystem hierarchy."
            },
            {
                "style": "Text",
                "text": "You may also add exchange data products nodes in bulk for all exchanges that may have been previously defined in the Crypto Ecosystem hierarchy. To do that, select <i>Add Missing Exchanges</i> on the parent node menu. An exchange data products node is created for each defined exchange, each with the corresponding reference."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "</code\">"
            }
        ],
        "starting": []
    },
    {
        "type": "Data Mines Data",
        "definition": "Session independent data refers to data generated by sensors and indicators, not related to trading sessions.",
        "content": [
            {
                "style": "Text",
                "text": "As explained in the sorting of tasks page, data mines data is sorted by exchange, market, and the corresponding data mine, sensor or indicator bot, and bot product. That is, most of the nodes in this section of the hierarchy play an organizational role."
            },
            {
                "style": "Text",
                "text": "Many of them require references to the nodes that delimit the context for which the data is applicable. For example, the market data products node must reference one of the installed markets, in particular, the market on which the data mining operation is run. These references help other entities understand the context to which the data belongs to."
            },
            {
                "style": "Text",
                "text": "Whenever you create data mining tasks manually from within the Network hierarchy (as opposed to using the install market function under the exchange markets node of the Crypto Ecosystem hierarchy"
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a session-independent data node, select <i>Add Session-independent Data</i> on the network node menu."
            },
            {
                "style": "Note",
                "text": "Only one session-independent data node may exist on each data storage node."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Project Data Products"
    },
    {
        "type": "Project Trading Products"
    },
    {
        "type": "Project Learning Products"
    },
    {
        "type": "Exchange Trading Products",
        "definition": "The exchange trading products node organizes trading mines data by exchange. That is, each exchange installed in the system has an exchange trading products node grouping all session references corresponding to the said exchange.",
        "content": [
            {
                "style": "Text",
                "text": "The exchange trading products node must reference the exchange of choice. This reference constraints the rest of the definitions to the context of the said exchange."
            },
            {
                "style": "Text",
                "text": "When representing an exchange featured in the system's icons library, the standard exchange trading products icon is replaced by the exchange's logo."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a specific exchange trading products node, select <i>Add Exchange Trading Products</i> on the parent node menu."
            },
            {
                "style": "Note",
                "text": "Remember to establish a reference to the desired exchange in the Crypto Ecosystem hierarchy."
            },
            {
                "style": "Text",
                "text": "You may also add exchange trading products nodes in bulk for all exchanges that may have been previously defined in the Crypto Ecosystem hierarchy. To do that, select <i>Add Missing Exchanges</i> on the trading mines data node menu. An exchange trading products node is created for each defined exchange, each with the corresponding reference."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "</code\">"
            }
        ],
        "starting": []
    },
    {
        "type": "Exchange Learning Products"
    },
    {
        "type": "Trading Mines Data",
        "definition": "Session-based data refers to data that is generated as a consequence of running a trading session, that is, data the trading bot instance generates while running backtesting, paper trading, forward testing, or live trading sessions.",
        "content": [
            {
                "style": "Text",
                "text": "As explained in the sorting of tasks page, trading mines data is sorted by exchange, market, the corresponding trading session, and the corresponding trading mine, trading bot, and bot product. That is, most of the nodes in this section of the hierarchy play an organizational role."
            },
            {
                "style": "Text",
                "text": "Many of them require references to the nodes that delimit the context for which the data is applicable. For example, the exchange trading products node must reference one of the installed exchanges, in particular, the exchange on which the trading operation is run. These references help other entities understand the context to which the data belongs to."
            },
            {
                "style": "Text",
                "text": "Whenever you create trading tasks manually from within the Network hierarchy (as opposed to using the install market function under the exchange markets node of the Crypto Ecosystem hierarchy"
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a session-based data node, select <i>Add Session-based Data</i> on the network node menu."
            },
            {
                "style": "Note",
                "text": "Only one session-based data node may exist on each data storage node."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Learning Mines Data"
    },
    {
        "type": "Trading Session Reference",
        "definition": "A session reference establishes which session is the one which shall store data in the current location.",
        "content": [
            {
                "style": "Text",
                "text": "A such, the session reference node must establish a reference with a trading session. Also, its offspring nodes determine precisely which data products are stored."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a session reference node, select <i>Add Session Reference</i> on the network node menu."
            },
            {
                "style": "Note",
                "text": "Remember to establish a reference with a trading session after adding the node."
            },
            {
                "style": "Text",
                "text": "You may also add session reference nodes in bulk for all sessions defined in the same network that are not yet defined. To do that, select <i>Add Missing Sessions</i> on the exchange trading products node menu. A session reference node is created for each defined trading session in the node, each with the corresponding reference."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Learning Session Reference"
    },
    {
        "type": "Market Data Products",
        "definition": "A market data products node represents the group of data products generated in a specific market.",
        "content": [
            {
                "style": "Text",
                "text": "The market data products node must reference a market defined in the Crypto Ecosystem hierarchy."
            },
            {
                "style": "Text",
                "text": "This node may spawn individual data products or may deploy data products in bulk organized by data mine and by bots. See the data products node for the details."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a market data products node, select <i>Add Market Data</i> on the parent node menu."
            },
            {
                "style": "Note",
                "text": "Remember to establish a reference with a market defined in the Crypto Ecosystem hierarchy after adding the node."
            },
            {
                "style": "Text",
                "text": "You may also add market data products nodes in bulk for all markets that may have been previously defined in the Crypto Ecosystem hierarchy. To do that, select <i>Add Missing Markets</i> on the parent node menu. A market data products node is created for each defined market, each with the corresponding reference."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Market Trading Products",
        "definition": "A market trading products node features the group of data products generated by the referenced session in a specific market.",
        "content": [
            {
                "style": "Text",
                "text": "The market trading products node must reference a market defined in the Crypto Ecosystem hierarchy."
            },
            {
                "style": "Text",
                "text": "This node may spawn individual data products or may deploy data products in bulk organized by trading mine and by trading bots. See the data products node for the details."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a market trading products node, select <i>Add Market Trading Data</i> on the parent node menu."
            },
            {
                "style": "Note",
                "text": "Remember to establish a reference with a market defined in the Crypto Ecosystem hierarchy after adding the node."
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Market Learning Products"
    },
    {
        "type": "Data Product",
        "definition": "A data product represents the collection of datasets generated by the instance of a bot as defined in the corresponding data mine or trading mine.",
        "content": [
            {
                "style": "Text",
                "text": "Data products exist in the context of trading mines data and data mines data nodes. In the first case, a data product is the collection of datasets generated by an instance of a trading bot as defined in a trading mine, running a trading session. In the latter case, it is the collection of datasets generated by either a sensor bot or an indicator bot instance, as defined in a data mine, and running a data mining task."
            },
            {
                "style": "Text",
                "text": "A data product node must reference a product definition in the corresponding bot."
            },
            {
                "style": "Important",
                "text": "Data products may only be stored on the same network node on which the task&mdash;data mining or trading&mdash;runs."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a single data product, select <i>Add Data Product</i> on the market trading products, market data products, bot products, or data products folder node menus."
            },
            {
                "style": "Note",
                "text": "Remember to establish a reference with a product definition of the corresponding bot in the corresponding data or trading mine."
            },
            {
                "style": "Text",
                "text": "In cases in which multiple data products must be added, you may use the option to create data products in bulk."
            },
            {
                "style": "Text",
                "text": "Select the <i>Add All Data Products</i> option on the data or trading mine products node menu. This adds a bot products node for each bot in the data or trading mine, and a data product for each product definition of each bot."
            },
            {
                "style": "Text",
                "text": "You may use this option after manually adding a data or trading mine products node and manually establishing the reference with the desired data mine, or after adding all data or trading mine data products, by which the references with data or trading mines are established automatically."
            },
            {
                "style": "Text",
                "text": "{% include tip.html content=\"If adding data products in bulk results in adding data products that are not required, you may easily delete those.\" %}"
            }
        ],
        "configuring": [],
        "starting": []
    },
    {
        "type": "Data Mine Products",
        "definition": "Data mine products are references established with data mines to facilitate establishing data product references with multiple products in the given data mine.",
        "content": [
            {
                "style": "Text",
                "text": "The node may be used as an organizational device, simply to arrange bot products. However, the smart use of the node involves automating the deployment of multiple data products."
            },
            {
                "style": "Text",
                "text": "The use of the data mine products node is optional, as data products may also exist outside of data mine products nodes."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a data mine products node, select <i>Add Data Mine Products</i> on the parent node menu. This action adds the node but does not establish a reference with any data mine."
            },
            {
                "style": "Text",
                "text": "The smarter use of the node involves using the <i>Add All Data Mine Products</i> option on the parent node menu. This action creates a data mine products node for each data mine in the workspace, establishing a reference with the corresponding data mines. This is the first step in the direction of quickly setting up multiple data products when needed."
            },
            {
                "style": "Note",
                "text": "See the data product node definition and the <i>Adding a Data Product Node</i> section for all the details."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "</code\">"
            }
        ],
        "starting": []
    },
    {
        "type": "Trading Mine Products",
        "definition": "Trading mine products are references established with trading mines to facilitate establishing data product references with multiple products in the given mine.",
        "content": [
            {
                "style": "Text",
                "text": "At this point, Superalgos ships with a single trading mine, featuring a single <i>low frequency</i> trading bot. However, developers may create their own trading bots or fork the existing one."
            },
            {
                "style": "Text",
                "text": "The node may be used as an organizational device, simply to arrange bot products. However, the smart use of the node involves automating the deployment of multiple data products."
            },
            {
                "style": "Text",
                "text": "The use of the trading mine products node is optional, as data products may also exist outside of trading mine products nodes."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a trading mine products node, select <i>Add Trading Mine Products</i> on the parent node menu. This action adds the node but does not establish a reference with any trading mine."
            },
            {
                "style": "Text",
                "text": "The smarter use of the node involves using the <i>Add All Trading Mine Products</i> option on the parent node menu. This action creates a trading mine products node for each trading mine in the workspace, establishing a reference with the corresponding trading mines. This is the first step in the direction of quickly setting up multiple data products when needed."
            },
            {
                "style": "Note",
                "text": "See the data product node definition and the <i>Adding a Data Product Node</i> section for all the details."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "</code\">"
            }
        ],
        "starting": []
    },
    {
        "type": "Learning Mine Products"
    },
    {
        "type": "Bot Products",
        "definition": "A bot products node is an organizational device used to arrange data products corresponding to a specific bot.",
        "content": [
            {
                "style": "Text",
                "text": "The device exists as an offspring of a data or trading mine products node, and does not require a reference to a bot in the given data or trading mine."
            },
            {
                "style": "Text",
                "text": "The use of the bot products node is optional, as data products may also exist outside of bot products."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a bot products node, select <i>Add Bot Products</i> on the parent node menu."
            },
            {
                "style": "Text",
                "text": "The bot products node may also be created automatically. When created using the <i>Add All Data Products</i> option on the data mine products node, the node inherits the label of the corresponding bot in the corresponding data mine."
            },
            {
                "style": "Note",
                "text": "See the data product node definition and the <i>Adding a Data Product Node</i> section for all the details."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "</code\">"
            }
        ],
        "starting": []
    },
    {
        "type": "Data Product Folder",
        "definition": "A data product folder node is an organizational device used to map the arrangement of product definition folders as may exist in the bot definition of the corresponding data or trading mine.",
        "content": [
            {
                "style": "Text",
                "text": "The use of the data product folder node is optional, as data products may also exist outside of data product folders."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the data product folder node, select <i>Add Data Product Folder</i> on the parent node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "</code\">"
            }
        ],
        "starting": []
    },
    {
        "type": "Plugins",
        "definition": "The plugins hierarchy defines which plugins are to be included in the current workspace. In the context of this hierarchy, plugins are JSON files featuring the description of a hierarchy such as a data mine, trading mine, trading engine, or trading system.",
        "content": [
            {
                "style": "Text",
                "text": "In the context of a community-driven project, a plugin is a device that serves to distribute community-generated intelligence. The project distributes several plugins contributed by the community."
            },
            {
                "style": "Text",
                "text": "{% include important.html content=\"Hierarchies included in the workspace as plugins are not saved at the workspace level. As such, changes made in those hierarchies do not persist. If you wish to modify a plugin and keep working with the modified version in the future, you must either clone or backup the plugin and work on the resulting copy instead. Learn more about the differences between backups and "
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the plugins node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "</code\">"
            }
        ],
        "starting": []
    },
    {
        "type": "Plugin Project",
        "definition": "In the context of a multi-project platform, the plugin project node represents the project to which the defined plugins correspond to.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the plugin project node, select <i>Add Missing Projects</i> on the parent node menu. The system adds a plugin project node for each project defined in the workspace."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "</code\">"
            }
        ],
        "starting": []
    },
    {
        "type": "Plugin Data Mines",
        "definition": "The plugin data mines node features the definitions of data mines to be included as plugins in the current workspace.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the plugin data mines node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "</code\">"
            }
        ],
        "starting": []
    },
    {
        "type": "Plugin Trading Mines",
        "definition": "The plugin trading mines node features the definitions of trading mines to be included as plugins in the current workspace.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the plugin trading mines node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "</code\">"
            }
        ],
        "starting": []
    },
    {
        "type": "Plugin Trading Systems",
        "definition": "The plugin data mines node features the definitions of data mines to be included as plugins in the current workspace.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the plugin trading systems node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "</code\">"
            }
        ],
        "starting": []
    },
    {
        "type": "Plugin Trading Engines",
        "definition": "The plugin data mines node features the definitions of data mines to be included as plugins in the current workspace.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the plugin trading engines node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "</code\">"
            }
        ],
        "starting": []
    },
    {
        "type": "Plugin Super Scripts",
        "definition": "The plugin super scripts node features the definitions of super scripts to be included as plugins in the current workspace.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the plugin super scripts node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "</code\">"
            }
        ],
        "starting": []
    },
    {
        "type": "Plugin Tutorials",
        "definition": "The plugin tutorials node features the definitions of tutorials to be included as plugins in the current workspace.",
        "content": [
            {
                "style": "Important",
                "text": "Tutorials included in the workspace as plugins do not keep track of users' progress, thus, may not return to the last step using the <i>Resume</i> button on the menu."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the plugin tutorials node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "</code\">"
            }
        ],
        "starting": []
    },
    {
        "type": "Plugin File",
        "definition": "A plugin file is the JSON file that constitutes the plugin. In the context of the plugins hierarchy, a plugin is the definition of a hierarchy.",
        "content": [
            {
                "style": "Text",
                "text": "Plugin files distributed with the system are stored in the corresponding folders on the following path: <code class=\"language-none\">\\Projects\\[ProjectName]\\Plugins\\</code>."
            },
            {
                "style": "Text",
                "text": "To create a plugin and make it available to the system you need to:"
            },
            {
                "style": "Text",
                "text": "1. Take a backup of the hierarchy."
            },
            {
                "style": "Text",
                "text": "2. Place it in the proper folder of the path."
            },
            {
                "style": "Text",
                "text": "{% include important.html content=\"Hierarchies included in the workspace as plugins are not saved at the workspace level. As such, changes made in those hierarchies do not persist. If you wish to modify a plugin and keep working with the modified version in the future, you must either clone or backup the plugin and work on the resulting copy instead. Learn more about the differences between backups and "
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the plugin file node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "</code\">"
            }
        ],
        "starting": []
    },
    {
        "type": "Plugin File Position",
        "definition": "The position of the plugin file position node determines the position in the workspace on which the plugin hierarchy is placed.",
        "content": [
            {
                "style": "Text",
                "text": "To define where the hierarchy defined in a plugin file is positioned in the workspace, move the plugin file position node to the desired position in the workspace, and pin the node. Then, collapse the plugin file node so that the plugin file position node is no longer visible."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the plugin file position node, select <i>Add Missing Items</i> on the parent node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "</code\">"
            }
        ],
        "starting": []
    },
    {
        "type": "Tutorial",
        "definition": "The tutorial hierarchy features a free arrangement of tutorial topic and tutorial step nodes that make up a tutorial. Each node in the hierarchy, including the parent tutorial node, represents a HTML page that is overlaid on top of both the design space and the charting space. ",
        "content": [
            {
                "style": "Text",
                "text": "Nodes in the hierarchy may be arranged freely, meaning that there may be as many tutorial topics and tutorial steps as desired. In general terms, all types of nodes behave similarly in the sense that each node, independently of the precise type, represents a tutorial step in and of itself. There are subtle differences to be covered where appropriate."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the tutorial node, select <i>Add Tutorial</i> on the parent node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "The configuration of each node in the tutorial hierarchy determines the content of each step. All types of nodes share the same basic configuration. However, tutorial step nodes have extra properties, described elsewhere."
            },
            {
                "style": "Text",
                "text": "The layout of the HTML page is fixed (CSS styles are fixed too) and is made out of a sequence of HTML elements, each of which may or may not be used, depending on whether the corresponding configuration parameter exists or not in the configuration."
            },
            {
                "style": "Success",
                "text": "In other words, you may choose which elements of a potentially long list are used by filling the corresponding parameters with content or not."
            },
            {
                "style": "Note",
                "text": "The HTML page features a limited space and does not support scrolling. If too much information is defined in the configuration, the resulting content overflows the available space. There is no system-side control to deal with such overflows, so it's up to you to spread information across multiple steps and keep each page within its limits."
            },
            {
                "style": "Text",
                "text": "{% include tip.html content=\"You may use HTML element tags and inline CSS as part of the content of parameters. Just consider that they shall be embedded in the fixed layout and their effectiveness may vary.\" %}"
            },
            {
                "style": "Text",
                "text": ""
            },
            {
                "style": "Text",
                "text": "Select <i>Configure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "{"
            },
            {
                "style": "Text",
                "text": "    \"title\": \"\","
            },
            {
                "style": "Text",
                "text": "    \"summary\": \"\","
            },
            {
                "style": "Text",
                "text": "    \"subTitle\": \"\","
            },
            {
                "style": "Text",
                "text": "    \"gif\": \"\","
            },
            {
                "style": "Text",
                "text": "    \"image\": \"\","
            },
            {
                "style": "Text",
                "text": "    \"definition\": \"\","
            },
            {
                "style": "Text",
                "text": "    \"bulletListIntro\": \"\","
            },
            {
                "style": "Text",
                "text": "    \"bulletArray\": ["
            },
            {
                "style": "Text",
                "text": "        ["
            },
            {
                "style": "Text",
                "text": "            \"\","
            },
            {
                "style": "Text",
                "text": "            \"\""
            },
            {
                "style": "Text",
                "text": "        ],"
            },
            {
                "style": "Text",
                "text": "        ["
            },
            {
                "style": "Text",
                "text": "            \"\","
            },
            {
                "style": "Text",
                "text": "            \"\""
            },
            {
                "style": "Text",
                "text": "        ],"
            },
            {
                "style": "Text",
                "text": "        ["
            },
            {
                "style": "Text",
                "text": "            \"\","
            },
            {
                "style": "Text",
                "text": "            \"\""
            },
            {
                "style": "Text",
                "text": "        ]"
            },
            {
                "style": "Text",
                "text": "    ],"
            },
            {
                "style": "Text",
                "text": "    \"paragraph1\": \"\","
            },
            {
                "style": "Text",
                "text": "    \"callOut\": \"\","
            },
            {
                "style": "Text",
                "text": "    \"externalLink\": ["
            },
            {
                "style": "Text",
                "text": "        \"\","
            },
            {
                "style": "Text",
                "text": "        \"\""
            },
            {
                "style": "Text",
                "text": "    ],"
            },
            {
                "style": "Text",
                "text": "    \"paragraph2\": \"\","
            },
            {
                "style": "Text",
                "text": "    \"note\": \"\","
            },
            {
                "style": "Text",
                "text": "    \"tip\": \"\","
            },
            {
                "style": "Text",
                "text": "    \"important\": \"\","
            },
            {
                "style": "Text",
                "text": "    \"warning\": \"\","
            },
            {
                "style": "Text",
                "text": "    \"position\": \"\","
            },
            {
                "style": "Text",
                "text": "    \"slider\": \"toTop\","
            },
            {
                "style": "Text",
                "text": "    \"pressButton\": \"\","
            },
            {
                "style": "Text",
                "text": "    \"documentationURL\": \"\""
            },
            {
                "style": "Text",
                "text": "}"
            },
            {
                "style": "Text",
                "text": "</code\">"
            },
            {
                "style": "Text",
                "text": "{% include tip.html content=\"Configuration items are listed in the order of appearance in the HTML layout, that is, the sequence of HTML elements mentioned earlier.\" %}"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">title</code> is the <code class=\"language-none\"><H1></code> tag, the main title of the page.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">summary</code> is a block of text preceded with the word <i>Summary</i>.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">subTitle</code> is the <code class=\"language-none\"><H2></code> tag, the secondary title of the page.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">gif</code> is the name of an image in the <i>GIF</i> format. Do not include the <code class=\"language-none\">.gif<code class=\"language-none\"> extension in the configuration, and make sure that the name of the file features the extension in lowercase. The file must be stored in the </code>\\Projects\\[Project-Name]\\Gifs</code>folder. The optimum size of the image is 400 px in width. For a step showing only a gif image, use 580 px for the height.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">image</code> is the name of one of the icons stored in the <code class=\"language-none\">\\Projects\\[Project-Name]\\Icons<code class=\"language-none\">folder, without the extension. When the configuration exists, the icon is placed within a table, on the left-hand side of the text block featured in the </code>definition</code> field. When there is no icon, the <code class=\"language-none\">definition</code> occupies the full width.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">definition</code> is a block of text in bold style (<code class=\"language-none\"><strong></code> HTML tag).</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">bulletListIntro</code> is a block of text that serves as an introduction to the array of bullet points below.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">bulletArray</code> is the definition of any number of bullet points. The first field on each bullet is rendered in bold style and the second, in plain style. If the fields are left empty, the bullet list will still be included in the HTML, therefore, if you don't want bullets you must delete the whole definition of the bullet array from the configuration.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">paragraph1</code> is a regular block of text.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">callOut</code> is a block of text in bold style with a green border and the left-hand side of the block.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">externalLink</code> allows you to set up a link that opens in a new tab at the end of the <code class=\"language-none\">callOut</code> block. Enter the URL in the first field and the anchor text in the second.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">paragraph2</code> is a regular block of text.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">note</code> is a block of text within a blue box preceded with the string <code class=\"language-none\">Note:</code>.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">tip</code> is a block of text within a green box preceded with the string <code class=\"language-none\">Tip:</code>.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">important</code> is a block of text within a yellow box preceded with the string <code class=\"language-none\">Important:</code>.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">warning</code> is a block of text within a red box preceded with the string <code class=\"language-none\">Warning:</code>.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">position</code> determines the position of the floating HTML. There are three alternatives: <code class=\"language-none\">Left<code class=\"language-none\">, </code>Right</code>, or leave the field empty to position the page in the center of the screen.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">slider</code> determines the position of the horizontal slider. There are four alternatives: <code class=\"language-none\">toTop<code class=\"language-none\">, </code>Right</code>, or leave the field empty to position the page in the center of the screen.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">pressButton</code> allows you to forcefully <code class=\"language-none\">Stop<code class=\"language-none\"> the tutorial, go to the </code>Next</code> step, go to the <code class=\"language-none\">Previous</code> step, or <code class=\"language-none\">Skip</code> a step. When a step is loaded and one of these options is configured in this field, the action is applied immediately.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">documentationURL</code> opens the Superalgos Documentation in the URL you configure. Use the complete URL, including the <code class=\"language-none\">https://</code> protocol header.</li></ul>"
            }
        ],
        "starting": []
    },
    {
        "type": "Tutorial Topic",
        "definition": "A tutorial topic is an organizational device that helps to keep tutorial step nodes arranged in a logical hierarchy by topics and subtopics.",
        "content": [
            {
                "style": "Text",
                "text": "Tutorial topics may be nested within other tutorial topics in unlimited levels, and each level may feature multiple tutorial steps."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the tutorial topic node, select <i>Add Tutorial Topic</i> on the parent node menu."
            }
        ],
        "configuring": [
            {
                "style": "Note",
                "text": "The configuration of the tutorial topic node is the same as the tutorial node. Refer to the latter, please."
            }
        ],
        "starting": []
    },
    {
        "type": "Tutorial Step",
        "definition": "A tutorial step is a type of node within a tutorial that may not have offspring. As such, it is the smallest unit of information in the hierarchy.",
        "content": [],
        "adding": [
            {
                "style": "Text",
                "text": "To add the tutorial step node, select <i>Add Tutorial Step</i> on the parent node menu."
            }
        ],
        "configuring": [
            {
                "style": "Note",
                "text": "The basic configuration of the tutorial step node is the same as the tutorial node. Refer to the latter, please."
            },
            {
                "style": "Text",
                "text": "In addition to the basic configuration, tutorial step nodes feature a large collection of resources that allows you to manipulate the user interface and actual nodes in many ways."
            },
            {
                "style": "Text",
                "text": "<H4>Navigation</H4>"
            },
            {
                "style": "Text",
                "text": "Setting up a reference to any node in the workspace and using the below parameter makes the step load next to the referenced node."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-none\">"
            },
            {
                "style": "Text",
                "text": "    \"positionAtReferenceParent\": true,"
            },
            {
                "style": "Text",
                "text": "</code>"
            },
            {
                "style": "Text",
                "text": "<H4>Messages</H4>"
            },
            {
                "style": "Text",
                "text": "Setting up a reference to any node in the workspace and using the below parameters allows placing different types of messages on the referenced node."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-none\">"
            },
            {
                "style": "Text",
                "text": "    \"setErrorMessageReferenceParent\": \"This is a simulated error message!\""
            },
            {
                "style": "Text",
                "text": "    \"setInfoMessageReferenceParent\": \"This is a simulated info message!\""
            },
            {
                "style": "Text",
                "text": "    \"setValueReferenceParent\": \"This is a simulated value message!\""
            },
            {
                "style": "Text",
                "text": "    \"setPercentageReferenceParent\": \"This is a simulated progress message!\""
            },
            {
                "style": "Text",
                "text": "    \"setStatusReferenceParent\": \"This is a simulated status message!\""
            },
            {
                "style": "Text",
                "text": "</code>"
            },
            {
                "style": "Text",
                "text": "<H4>Centering and Zooming Into a Time Machine</H4>"
            },
            {
                "style": "Text",
                "text": "Setting up a reference to a time machine node in the charting space hierarchy while using the below parameter causes the following:"
            },
            {
                "style": "Text",
                "text": "<ul><li>The charting space viewport is centered on the referenced time machine.</li>"
            },
            {
                "style": "Text",
                "text": "<li>The time machine is adjusted to fit the aspect ratio of the screen.</li>"
            },
            {
                "style": "Text",
                "text": "<li>The viewport zooms into the time machine.</li>"
            },
            {
                "style": "Text",
                "text": "</ul>"
            },
            {
                "style": "Text",
                "text": "    \"repositionAtTimeMachineReferenceParent\": true,"
            },
            {
                "style": "Text",
                "text": "</code>"
            },
            {
                "style": "Text",
                "text": "<H4>Pressing Keys When on a Time Machine</H4>"
            },
            {
                "style": "Text",
                "text": "Setting up a reference to a time machine node in the charting space hierarchy and using the below parameters allows simulating the pressing of relevant key combinations when on a time machine."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-none\">"
            },
            {
                "style": "Text",
                "text": "    \"keyPressedTimeMachineReferenceParent\": {"
            },
            {
                "style": "Text",
                "text": "        \"shiftKey\": true,"
            },
            {
                "style": "Text",
                "text": "        \"ctrlKey\": true,"
            },
            {
                "style": "Text",
                "text": "        \"metaKey\": true,"
            },
            {
                "style": "Text",
                "text": "        \"key\": \"A\""
            },
            {
                "style": "Text",
                "text": "    }"
            },
            {
                "style": "Text",
                "text": "</code>"
            },
            {
                "style": "Text",
                "text": "<ul><li><code class=\"language-none\">shiftKey</code>, <code class=\"language-none\">ctrlKey<code class=\"language-none\">, and </code>metaKey</code> (Mac OS equivalent to Control) may be <code class=\"language-none\">true</code> or <code class=\"language-none\">false</code>.</li>"
            },
            {
                "style": "Text",
                "text": "<li><code class=\"language-none\">key</code> may be any letter or number.</li>"
            },
            {
                "style": "Text",
                "text": "</ul>"
            },
            {
                "style": "Text",
                "text": "Setting up a reference to any node in the design space and using the following parameters allows you to edit the configuration of the referenced nodes and their offspring."
            },
            {
                "style": "Text",
                "text": "The example below changes the configuration of the three different scale nodes under a time machine. In this case, the time machine is the node referenced, the <code class=\"language-none\">nodePath</code> is the path of the node whose configuration must be changed relative to the <code class=\"language-none\">referenceParent<code class=\"language-none\">, and the </code>properties</code> parameter is the actual configuration to be set."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-none\">"
            },
            {
                "style": "Text",
                "text": "    \"batchConfigChangesReferenceParent\": ["
            },
            {
                "style": "Text",
                "text": "        {"
            },
            {
                "style": "Text",
                "text": "            \"nodePath\": \"referenceParent.timeScale\","
            },
            {
                "style": "Text",
                "text": "            \"properties\": {"
            },
            {
                "style": "Text",
                "text": "                \"autoMinScale\": false,"
            },
            {
                "style": "Text",
                "text": "                \"autoMaxScale\": false,"
            },
            {
                "style": "Text",
                "text": "                \"fromDate\": \"2020-08-31T23:40:00.000Z\","
            },
            {
                "style": "Text",
                "text": "                \"toDate\": \"2020-09-01T01:00:00.000Z\""
            },
            {
                "style": "Text",
                "text": "            }"
            },
            {
                "style": "Text",
                "text": "        },"
            },
            {
                "style": "Text",
                "text": "        {"
            },
            {
                "style": "Text",
                "text": "            \"nodePath\": \"referenceParent.rateScale\","
            },
            {
                "style": "Text",
                "text": "            \"properties\": {"
            },
            {
                "style": "Text",
                "text": "                \"autoMinScale\": false,"
            },
            {
                "style": "Text",
                "text": "                \"autoMaxScale\": false,"
            },
            {
                "style": "Text",
                "text": "                \"minValue\": 11400,"
            },
            {
                "style": "Text",
                "text": "                \"maxValue\": 11800"
            },
            {
                "style": "Text",
                "text": "            }"
            },
            {
                "style": "Text",
                "text": "        },"
            },
            {
                "style": "Text",
                "text": "        {"
            },
            {
                "style": "Text",
                "text": "            \"nodePath\": \"referenceParent.timeFrameScale\","
            },
            {
                "style": "Text",
                "text": "            \"properties\": {"
            },
            {
                "style": "Text",
                "text": "                \"value\": \"01-min\""
            },
            {
                "style": "Text",
                "text": "            }"
            },
            {
                "style": "Text",
                "text": "        }"
            },
            {
                "style": "Text",
                "text": "    ]"
            },
            {
                "style": "Text",
                "text": "</code>"
            }
        ],
        "starting": []
    },
    {
        "type": "Data Mine Data Dependencies",
        "definition": "Data mine data dependencies are references established with entire data mines to facilitate establishing data dependencies with multiple datasets in the given data mine.",
        "content": [
            {
                "style": "Text",
                "text": "The node may be used as an organizational device, simply to arrange bot data dependencies. However, the smart use of the node involves automating the deployment of multiple data dependencies and their references."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add a data mine data dependencies node, select <i>Add Data Mine Data Dependencies</i> on the parent node menu. This action adds the node but does not establish a reference with any data mine."
            },
            {
                "style": "Text",
                "text": "The smarter use of the node involves using the <i>Add All Data Mine Dependencies</i> option on the parent node menu. This action creates a data mine data dependencies node for each data mine in the workspace, establishing a reference with the corresponding data mines. This is the first step in the direction of quickly setting up multiple data dependencies when needed."
            },
            {
                "style": "Note",
                "text": "See the data dependency node definition and the <i>Adding a Data Dependecy Node</i> section for all the details."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "</code\">"
            }
        ],
        "starting": []
    },
    {
        "type": "Bot Data Dependencies",
        "definition": "A bot data dependencies node is an organizational device used to arrange data dependencies corresponding to a specific bot.",
        "content": [
            {
                "style": "Text",
                "text": "The device exists as an offspring of a data mine data dependencies node, and does not require a reference to a bot in the given data mine."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the bot data dependencies node, select <i>Add Bot Data Dependencies</i> on the parent node menu. When adding a bot data dependency in this manner, the node does not inherit any particular label. In fact, it may even host data dependencies pointing to other data mines."
            },
            {
                "style": "Text",
                "text": "The bot data dependencies node may also be created automatically. When created using the <i>Add All Data Dependencies</i> option on the data mine data dependencies node, the node inherits the label of the corresponding bot in the corresponding data mine."
            },
            {
                "style": "Note",
                "text": "See the data dependency node definition and the <i>Adding a Data Dependecy Node</i> section for all the details."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "</code\">"
            }
        ],
        "starting": []
    },
    {
        "type": "Data Dependency Folder",
        "definition": "A data dependency folder node is an organizational device used to map the arrangement of product definition folders of a given bot.",
        "content": [
            {
                "style": "Text",
                "text": "The use of product data dependency folders is optional, as data dependencies may also exist outside of folders."
            }
        ],
        "adding": [
            {
                "style": "Text",
                "text": "To add the data dependency folder node, select <i>Add Data Dependency Folder</i> on the parent node menu."
            },
            {
                "style": "Text",
                "text": "The data dependency folder node may be added automatically when using the <i>Add All Data Dependencies</i> option on the data mine data dependencies node menu."
            }
        ],
        "configuring": [
            {
                "style": "Text",
                "text": "Select <i>Configure</i> on the menu to access the configuration."
            },
            {
                "style": "Text",
                "text": "<code class=\"language-json\">"
            },
            {
                "style": "Text",
                "text": "</code\">"
            }
        ],
        "starting": []
    }
]